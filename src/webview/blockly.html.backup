<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TextBlockly - Arduino Visual Programming</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);
        }

        .container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        .toolbar {
            background-color: var(--vscode-titleBar-activeBackground);
            color: var(--vscode-titleBar-activeForeground);
            padding: 8px 16px;
            border-bottom: 1px solid var(--vscode-panel-border);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toolbar button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .toolbar button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }

        .toolbar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .blockly-area {
            flex: 1;
            position: relative;
        }

        #blocklyDiv {
            height: 100%;
            width: 100%;
        }

        .status-bar {
            background-color: var(--vscode-statusBar-background);
            color: var(--vscode-statusBar-foreground);
            padding: 4px 16px;
            font-size: 11px;
            border-top: 1px solid var(--vscode-panel-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .loading {
            display: none;
            align-items: center;
            gap: 8px;
        }

        .spinner {
            width: 12px;
            height: 12px;
            border: 2px solid transparent;
            border-top: 2px solid var(--vscode-progressBar-background);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background-color: var(--vscode-inputValidation-errorBackground);
            color: var(--vscode-inputValidation-errorForeground);
            border: 1px solid var(--vscode-inputValidation-errorBorder);
            padding: 8px 12px;
            margin: 8px;
            border-radius: 4px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å·¥å…·åˆ— -->
        <div class="toolbar">
            <button id="saveBtn" title="å„²å­˜ç‚ºæ¨¡æ¿">ğŸ’¾ å„²å­˜</button>
            <button id="loadBtn" title="è¼‰å…¥æ¨¡æ¿">ğŸ“ è¼‰å…¥</button>
            <button id="clearBtn" title="æ¸…ç©ºå·¥ä½œå€">ğŸ—‘ï¸ æ¸…ç©º</button>
            <button id="testBtn" title="å‰µå»ºæ¸¬è©¦ç©æœ¨">ğŸ§ª æ¸¬è©¦</button>
            <div style="border-left: 1px solid var(--vscode-panel-border); margin: 0 8px; height: 20px;"></div>
            <button id="syncToCodeBtn" title="å°‡ç©æœ¨åŒæ­¥åˆ°ç¨‹å¼ç¢¼">â¡ï¸ åŒæ­¥åˆ°ç¨‹å¼ç¢¼</button>
            <button id="syncToBlocksBtn" title="å°‡ç¨‹å¼ç¢¼åŒæ­¥åˆ°ç©æœ¨">â¬…ï¸ åŒæ­¥åˆ°ç©æœ¨</button>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <span>åŒæ­¥ä¸­...</span>
            </div>
        </div>

        <!-- éŒ¯èª¤è¨Šæ¯ -->
        <div class="error-message" id="errorMessage"></div>

        <!-- ä¸»è¦å…§å®¹å€åŸŸ -->
        <div class="main-content">
            <!-- Blockly å·¥ä½œå€ -->
            <div class="blockly-area">
                <div id="blocklyDiv"></div>
            </div>
        </div>

        <!-- ç‹€æ…‹åˆ— -->
        <div class="status-bar">
            <div class="status-item">
                <span>ç©æœ¨æ•¸é‡: </span>
                <span id="blockCount">0</span>
            </div>
            <div class="status-item">
                <span id="syncStatus">å°±ç·’ - ç¨‹å¼ç¢¼å³æ™‚åŒæ­¥åˆ°å³å´ç·¨è¼¯å™¨</span>
            </div>
        </div>
    </div>

    <!-- Blockly æ ¸å¿ƒåº« -->
    <script src="{{BLOCKLY_PATH}}/blockly_compressed.js"></script>
    <script src="{{BLOCKLY_PATH}}/blocks_compressed.js"></script>
    <script src="{{BLOCKLY_PATH}}/msg/zh-hant.js"></script>

    <script>
        // å…¨åŸŸè®Šæ•¸
        let workspace;
        let vscode;
        let codeGenerationTimer;

        // VSCode API
        if (typeof acquireVsCodeApi !== 'undefined') {
            vscode = acquireVsCodeApi();
        } else {
            // é–‹ç™¼ç’°å¢ƒæ¨¡æ“¬
            vscode = {
                postMessage: (message) => console.log('VSCode Message:', message),
                getState: () => null,
                setState: (state) => console.log('VSCode State:', state)
            };
        }

        // Arduino ç©æœ¨å®šç¾©
        const ARDUINO_BLOCKS = {{ARDUINO_BLOCKS}};

        // å·¥å…·ç®±é…ç½®
        const TOOLBOX = {{TOOLBOX}};

        // è®Šæ•¸è¨ˆæ•¸å™¨ç”¨æ–¼ç”Ÿæˆé è¨­åç¨±
        let variableCounter = 1;

        // å…¨å±€è¦†è“‹ prompt å‡½æ•¸ä»¥é¡¯ç¤ºè‡ªå®šç¾©å°è©±æ¡†
        window.prompt = function(message, defaultValue) {
            console.log('ğŸ”¥ PROMPT INTERCEPTED:', {
                message: message,
                defaultValue: defaultValue,
                timestamp: new Date().toISOString()
            });

            // æª¢æŸ¥æ˜¯å¦ç‚ºè®Šæ•¸å‰µå»ºç›¸é—œçš„æç¤º
            if (message && (message.includes('variable') || message.includes('è®Šæ•¸') || message.includes('name') ||
                           message.includes('Create') || message.includes('New'))) {

                // ç”Ÿæˆé è¨­è®Šæ•¸åç¨±
                const suggestedName = defaultValue || `variable${variableCounter}`;
                variableCounter++;

                console.log('ğŸ¯ Variable creation detected:', {
                    suggestedName: suggestedName,
                    counter: variableCounter,
                    workspaceAvailable: !!workspace
                });

                // é¡¯ç¤ºç•°æ­¥å°è©±æ¡†ï¼Œå¦‚æœç”¨æˆ¶æ›´æ”¹åç¨±ï¼Œå‰‡æ›´æ–°è®Šæ•¸
                setTimeout(() => {
                    console.log('â° Starting async dialog for variable:', suggestedName);

                    showVariableNameDialogAsync(message, suggestedName, (userResult) => {
                        console.log('ğŸ“¨ Async dialog callback received:', {
                            userResult: userResult,
                            originalName: suggestedName,
                            changed: userResult !== suggestedName
                        });

                        if (userResult && userResult !== suggestedName && workspace && workspace.createVariable) {
                            console.log('ğŸ”„ User changed variable name, attempting replacement...');

                            try {
                                // å…ˆæŸ¥æ‰¾é è¨­è®Šæ•¸
                                const allVars = workspace.getAllVariables();
                                console.log('ğŸ“‹ Current variables:', allVars.map(v => v.name));

                                const defaultVar = workspace.getVariable(suggestedName);
                                if (defaultVar) {
                                    console.log('ğŸ—‘ï¸ Deleting default variable:', suggestedName);
                                    workspace.deleteVariableById(defaultVar.getId());
                                } else {
                                    console.log('âš ï¸ Default variable not found:', suggestedName);
                                }

                                // å‰µå»ºç”¨æˆ¶æŒ‡å®šçš„è®Šæ•¸
                                console.log('â• Creating user variable:', userResult);
                                const newVar = workspace.createVariable(userResult, null, userResult);
                                console.log('âœ… Successfully created user variable:', {
                                    name: newVar.name,
                                    id: newVar.getId()
                                });

                                // åˆ·æ–°å·¥å…·ç®±ä»¥æ›´æ–°è®Šæ•¸åˆ—è¡¨
                                if (workspace.refreshToolboxSelection) {
                                    workspace.refreshToolboxSelection();
                                }

                            } catch (error) {
                                console.error('âŒ Error updating variable name:', error);
                            }
                        } else if (!userResult) {
                            console.log('âŒ User cancelled variable creation');
                        } else if (userResult === suggestedName) {
                            console.log('ğŸ“ User kept the suggested name:', suggestedName);
                        } else if (!workspace) {
                            console.error('âŒ Workspace not available for variable update');
                        }
                    });
                }, 150); // å¢åŠ å»¶é²ä»¥ç¢ºä¿ Blockly å®Œå…¨åˆå§‹åŒ–

                // ç«‹å³è¿”å›é è¨­åç¨±çµ¦ Blockly
                console.log('ğŸ“¤ Returning default name to Blockly:', suggestedName);
                return suggestedName;
            }

            // å°æ–¼å…¶ä»–æç¤ºï¼Œè¿”å›é»˜èªå€¼æˆ–ç©ºå­—ç¬¦ä¸²
            console.log('â“ Non-variable prompt, returning default:', defaultValue || '');
            return defaultValue || '';
        };

        // åˆå§‹åŒ– Blockly
        function initBlockly() {
            try {
                // è¨»å†Š Arduino ç©æœ¨
                registerArduinoBlocks();

                // å‰µå»ºå·¥ä½œå€
                workspace = Blockly.inject('blocklyDiv', {
                    toolbox: TOOLBOX,
                    grid: {
                        spacing: 20,
                        length: 3,
                        colour: '#ccc',
                        snap: true
                    },
                    zoom: {
                        controls: true,
                        wheel: true,
                        startScale: 1.0,
                        maxScale: 3,
                        minScale: 0.3,
                        scaleSpeed: 1.2
                    },
                    trashcan: true,
                    theme: Blockly.Themes.Classic
                });

                // ç›£è½å·¥ä½œå€è®Šæ›´
                workspace.addChangeListener(onWorkspaceChange);

                // åˆå§‹åŒ–è®Šæ•¸ç³»çµ± - å‰µå»ºé è¨­è®Šæ•¸ä»¥å•Ÿç”¨è®Šæ•¸åŠŸèƒ½
                console.log('ğŸ”§ Initializing variable system...');
                if (workspace.createVariable) {
                    workspace.createVariable('item', null, 'item');
                    console.log('âœ… Created default variable: item');
                } else {
                    console.warn('âŒ workspace.createVariable not available');
                }

                // æª¢æŸ¥è®Šæ•¸ç®¡ç†ç³»çµ±
                if (Blockly.Variables) {
                    console.log('âœ… Blockly.Variables is available');
                    console.log('Variables methods:', Object.keys(Blockly.Variables));
                } else {
                    console.warn('âŒ Blockly.Variables not available');
                }

                // æª¢æŸ¥å·¥å…·ç®±ä¸­çš„è®Šæ•¸é¡åˆ¥
                console.log('ğŸ“Š Checking variable category in toolbox...');
                const toolboxXml = workspace.getToolbox();
                if (toolboxXml) {
                    console.log('âœ… Toolbox found');
                } else {
                    console.warn('âŒ No toolbox found');
                }

                console.log('âœ… Variable creation will be handled by global prompt() override');

                // æ‰‹å‹•åŒæ­¥æ¨¡å¼ - ä¸è‡ªå‹•ç”Ÿæˆç¨‹å¼ç¢¼
                console.log('Blockly initialized in manual sync mode');

                // é€šçŸ¥ VSCode Blockly å·²æº–å‚™å°±ç·’
                vscode.postMessage({
                    command: 'blocklyReady',
                    data: { blockCount: workspace.getAllBlocks().length }
                });

                console.log('Blockly åˆå§‹åŒ–æˆåŠŸï¼Œå·²é€šçŸ¥ VSCode');
            } catch (error) {
                showError('Blockly åˆå§‹åŒ–å¤±æ•—: ' + error.message);
                console.error('Blockly åˆå§‹åŒ–éŒ¯èª¤:', error);
            }
        }

        // è¨»å†Š Arduino ç©æœ¨
        function registerArduinoBlocks() {
            ARDUINO_BLOCKS.forEach(block => {
                Blockly.Blocks[block.type] = {
                    init: function() {
                        this.jsonInit(block);
                    }
                };
            });

            // ç¢ºä¿è®Šæ•¸ç©æœ¨æ­£ç¢ºè¨»å†Šåˆ° Blockly çš„è®Šæ•¸ç³»çµ±
            // é€™æ˜¯è®“è®Šæ•¸å·¥å…·ç®±æ­£å¸¸å·¥ä½œçš„é—œéµ
            if (!Blockly.Blocks['variables_get']) {
                Blockly.Blocks['variables_get'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'variables_get',
                            message0: '%1',
                            args0: [{
                                type: 'field_variable',
                                name: 'VAR',
                                variable: 'item'
                            }],
                            output: null,
                            colour: 330,
                            tooltip: 'å–å¾—è®Šæ•¸çš„å€¼',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['variables_set']) {
                Blockly.Blocks['variables_set'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'variables_set',
                            message0: 'è¨­å®š %1 ç‚º %2',
                            args0: [
                                {
                                    type: 'field_variable',
                                    name: 'VAR',
                                    variable: 'item'
                                },
                                {
                                    type: 'input_value',
                                    name: 'VALUE'
                                }
                            ],
                            previousStatement: null,
                            nextStatement: null,
                            colour: 330,
                            tooltip: 'è¨­å®šè®Šæ•¸çš„å€¼',
                            helpUrl: ''
                        });
                    }
                };
            }
        }

        // ç°¡å–®çš„æ¸¬è©¦å°è©±æ¡†
        function showSimpleTestDialog() {
            console.log('ğŸ§ª Creating simple test dialog');

            // å‰µå»ºä¸€å€‹éå¸¸ç°¡å–®çš„å°è©±æ¡†
            const testOverlay = document.createElement('div');
            testOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: red;
                z-index: 999999;
                display: flex;
                justify-content: center;
                align-items: center;
            `;

            const testBox = document.createElement('div');
            testBox.style.cssText = `
                background: yellow;
                padding: 50px;
                border: 5px solid black;
                font-size: 24px;
                color: black;
            `;
            testBox.textContent = 'TEST DIALOG - CLICK TO CLOSE';

            testBox.addEventListener('click', () => {
                document.body.removeChild(testOverlay);
                console.log('ğŸ§ª Simple test dialog closed');
            });

            testOverlay.appendChild(testBox);
            document.body.appendChild(testOverlay);
            console.log('ğŸ§ª Simple test dialog added to DOM');
        }

        // é¡¯ç¤ºè®Šæ•¸åç¨±è¼¸å…¥å°è©±æ¡†ï¼ˆç•°æ­¥ç‰ˆæœ¬ï¼‰
        function showVariableNameDialogAsync(message, suggestedName, callback) {
            console.log('ğŸ¨ Creating async variable dialog:', message, suggestedName);
            // å‰µå»ºå°è©±æ¡†å…ƒç´ 
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 999999;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #2d2d30;
                border: 2px solid #007acc;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                min-width: 320px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            `;

            const title = document.createElement('h3');
            title.textContent = message || 'å»ºç«‹æ–°è®Šæ•¸';
            title.style.cssText = 'margin: 0 0 15px 0; color: #ffffff; font-size: 18px;';

            const description = document.createElement('p');
            description.textContent = 'è«‹è¼¸å…¥è®Šæ•¸åç¨±ï¼š';
            description.style.cssText = 'margin: 0 0 10px 0; color: #cccccc; font-size: 14px;';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = suggestedName;
            input.placeholder = 'è®Šæ•¸åç¨±...';
            input.style.cssText = `
                width: 100%;
                padding: 10px;
                border: 2px solid #007acc;
                border-radius: 4px;
                font-size: 14px;
                margin-bottom: 20px;
                box-sizing: border-box;
                outline: none;
                background: #1e1e1e;
                color: #ffffff;
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'å–æ¶ˆ';
            cancelButton.style.cssText = `
                padding: 10px 20px;
                border: 2px solid #666;
                background: #3c3c3c;
                color: #ffffff;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            `;

            const confirmButton = document.createElement('button');
            confirmButton.textContent = 'å»ºç«‹';
            confirmButton.style.cssText = `
                padding: 10px 20px;
                border: 2px solid #007acc;
                background: #007acc;
                color: #ffffff;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            `;

            // ç•°æ­¥äº‹ä»¶è™•ç†
            function closeDialog(returnValue) {
                console.log('ğŸšª Async dialog closing with result:', returnValue);
                try {
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                        console.log('ğŸ—‘ï¸ Async dialog removed from DOM');
                    }
                } catch (e) {
                    console.warn('Error removing async dialog from DOM:', e);
                }
                // èª¿ç”¨å›èª¿å‡½æ•¸
                callback(returnValue);
            }

            cancelButton.addEventListener('click', () => {
                closeDialog(null);
            });

            confirmButton.addEventListener('click', () => {
                const variableName = input.value.trim();
                closeDialog(variableName || null);
            });

            // éµç›¤äº‹ä»¶
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    confirmButton.click();
                } else if (e.key === 'Escape') {
                    cancelButton.click();
                }
            });

            // çµ„è£å°è©±æ¡†
            buttonContainer.appendChild(cancelButton);
            buttonContainer.appendChild(confirmButton);

            dialog.appendChild(title);
            dialog.appendChild(description);
            dialog.appendChild(input);
            dialog.appendChild(buttonContainer);

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            console.log('ğŸ“± Async dialog added to DOM');

            // èšç„¦è¼¸å…¥æ¡†ä¸¦é¸ä¸­æ–‡å­—
            setTimeout(() => {
                input.focus();
                input.select();
                console.log('ğŸ¯ Async dialog input focused');
            }, 50);

            // é»æ“Šè¦†è“‹å±¤é—œé–‰
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeDialog(null);
                }
            });
        }


            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #2d2d30;
                border: 2px solid #007acc;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                min-width: 320px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            `;

            const title = document.createElement('h3');
            title.textContent = 'å»ºç«‹æ–°è®Šæ•¸';
            title.style.cssText = 'margin: 0 0 15px 0; color: #ffffff; font-size: 18px;';

            const description = document.createElement('p');
            description.textContent = 'è«‹è¼¸å…¥è®Šæ•¸åç¨±ï¼š';
            description.style.cssText = 'margin: 0 0 10px 0; color: #cccccc; font-size: 14px;';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = suggestedName;
            input.placeholder = 'è®Šæ•¸åç¨±...';
            input.style.cssText = `
                width: 100%;
                padding: 10px;
                border: 2px solid #007acc;
                border-radius: 4px;
                font-size: 14px;
                margin-bottom: 20px;
                box-sizing: border-box;
                outline: none;
                background: #1e1e1e;
                color: #ffffff;
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'å–æ¶ˆ';
            cancelButton.style.cssText = `
                padding: 10px 20px;
                border: 2px solid #666;
                background: #3c3c3c;
                color: #ffffff;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            `;

            const confirmButton = document.createElement('button');
            confirmButton.textContent = 'å»ºç«‹';
            confirmButton.style.cssText = `
                padding: 10px 20px;
                border: 2px solid #007acc;
                background: #007acc;
                color: #ffffff;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            `;

            // è®Šæ•¸ä¾†å„²å­˜çµæœ
            let result = null;
            let dialogClosed = false;

            // äº‹ä»¶è™•ç†
            function closeDialog(returnValue) {
                if (dialogClosed) {
                    console.log('âš ï¸ Dialog already closed, ignoring');
                    return;
                }
                console.log('ğŸšª Closing dialog with result:', returnValue);
                dialogClosed = true;
                result = returnValue;
                try {
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                        console.log('ğŸ—‘ï¸ Dialog removed from DOM');
                    }
                } catch (e) {
                    console.warn('Error removing dialog from DOM:', e);
                }
            }

            cancelButton.addEventListener('click', () => {
                closeDialog(null);
            });

            confirmButton.addEventListener('click', () => {
                const variableName = input.value.trim();
                closeDialog(variableName || null);
            });

            // éµç›¤äº‹ä»¶
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    confirmButton.click();
                } else if (e.key === 'Escape') {
                    cancelButton.click();
                }
            });

            input.addEventListener('focus', () => {
                input.style.borderColor = '#00d4ff';
            });

            input.addEventListener('blur', () => {
                input.style.borderColor = '#007acc';
            });

            // æŒ‰éˆ•æ‡¸åœæ•ˆæœ
            cancelButton.addEventListener('mouseover', () => {
                cancelButton.style.background = '#484848';
            });
            cancelButton.addEventListener('mouseout', () => {
                cancelButton.style.background = '#3c3c3c';
            });

            confirmButton.addEventListener('mouseover', () => {
                confirmButton.style.background = '#005a9e';
            });
            confirmButton.addEventListener('mouseout', () => {
                confirmButton.style.background = '#007acc';
            });

            // çµ„è£å°è©±æ¡†
            buttonContainer.appendChild(cancelButton);
            buttonContainer.appendChild(confirmButton);

            dialog.appendChild(title);
            dialog.appendChild(description);
            dialog.appendChild(input);
            dialog.appendChild(buttonContainer);

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            console.log('ğŸ“± Dialog added to DOM');

            // èšç„¦è¼¸å…¥æ¡†ä¸¦é¸ä¸­æ–‡å­—
            setTimeout(() => {
                input.focus();
                input.select();
                console.log('ğŸ¯ Input focused and selected');
            }, 50);

            // é»æ“Šè¦†è“‹å±¤é—œé–‰
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeDialog(null);
                }
            });

            // ä½¿ç”¨æ›´å®‰å…¨çš„åŒæ­¥ç­‰å¾…æ–¹æ³•
            console.log('ğŸ”„ Showing dialog and waiting for result...');

            // ä½¿ç”¨æ›´çŸ­çš„æª¢æŸ¥é–“éš”ï¼Œé¿å…å‡çµ
            const start = Date.now();
            const timeout = 30000; // 30ç§’è¶…æ™‚

            // è®“ç€è¦½å™¨æœ‰æ™‚é–“æ¸²æŸ“å°è©±æ¡†
            const now = performance.now();
            while (performance.now() - now < 100) {
                // å…è¨±ç€è¦½å™¨è™•ç† DOM æ›´æ–°
            }

            // ä½¿ç”¨æ›´æº«å’Œçš„ç­‰å¾…å¾ªç’°
            while (!dialogClosed && (Date.now() - start) < timeout) {
                // æ›´çŸ­çš„å¿™ç­‰å¾…é–“éš”
                const checkStart = performance.now();
                while (performance.now() - checkStart < 5) {
                    // åªç­‰å¾… 5ms
                }
            }

            // è¶…æ™‚æˆ–å®Œæˆè™•ç†
            if (!dialogClosed) {
                console.warn('â° Dialog timeout after', Date.now() - start, 'ms, using suggested name');
                try {
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                        console.log('ğŸ—‘ï¸ Removed timeout dialog from DOM');
                    }
                } catch (e) {
                    console.warn('Error removing dialog:', e);
                }
                result = suggestedName;
                dialogClosed = true;
            }

            console.log('âœ… Dialog completed, result:', result, 'took:', Date.now() - start, 'ms');
            return result || suggestedName;
        }

        // å·¥ä½œå€è®Šæ›´äº‹ä»¶ï¼ˆæ‰‹å‹•åŒæ­¥æ¨¡å¼ - åƒ…æ›´æ–°è¨ˆæ•¸ï¼‰
        function onWorkspaceChange(event) {
            console.log('Workspace change event:', event.type);

            // åƒ…æ›´æ–°ç©æœ¨æ•¸é‡ï¼Œä¸è‡ªå‹•åŒæ­¥
            updateBlockCount();

            // æ‰‹å‹•åŒæ­¥æ¨¡å¼ - ä¸è‡ªå‹•ç”Ÿæˆç¨‹å¼ç¢¼æˆ–ç™¼é€è®Šæ›´é€šçŸ¥
            console.log('Manual sync mode - auto sync disabled');
        }

        // ç”Ÿæˆç¨‹å¼ç¢¼
        function generateCode() {
            try {
                console.log('generateCode called');
                const code = generateArduinoCode();
                console.log('Generated code:', code.substring(0, 100));

                // æ™ºèƒ½å³æ™‚åŒæ­¥åˆ°å³å´ç·¨è¼¯å™¨
                console.log('Sending smartSyncCode message to VSCode');
                vscode.postMessage({
                    command: 'smartSyncCode',
                    data: { code: code }
                });

                hideError();
            } catch (error) {
                showError('ç¨‹å¼ç¢¼ç”Ÿæˆå¤±æ•—: ' + error.message);
                console.error('ç¨‹å¼ç¢¼ç”ŸæˆéŒ¯èª¤:', error);
            }
        }

        // ç”Ÿæˆ Arduino ç¨‹å¼ç¢¼
        function generateArduinoCode() {
            const setupBlocks = workspace.getBlocksByType('arduino_setup');
            const loopBlocks = workspace.getBlocksByType('arduino_loop');

            let setupCode = '  // åˆå§‹åŒ–ç¨‹å¼ç¢¼';
            let loopCode = '  // ä¸»è¦ç¨‹å¼é‚è¼¯';

            if (setupBlocks.length > 0) {
                const generatedSetup = generateBlockCode(setupBlocks[0].getInputTargetBlock('SETUP_CODE'), '  ');
                if (generatedSetup && generatedSetup.trim() !== '// è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡') {
                    setupCode = generatedSetup;
                }
            }

            if (loopBlocks.length > 0) {
                const generatedLoop = generateBlockCode(loopBlocks[0].getInputTargetBlock('LOOP_CODE'), '  ');
                if (generatedLoop && generatedLoop.trim() !== '// è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡') {
                    loopCode = generatedLoop;
                }
            }

            // ç¢ºä¿ç¨‹å¼ç¢¼æœ‰æ­£ç¢ºçš„ç¸®æ’
            const formattedSetupCode = formatCodeLines(setupCode, '  ');
            const formattedLoopCode = formatCodeLines(loopCode, '  ');

            // ç”Ÿæˆæ™‚é–“æˆ³
            const now = new Date();
            const timestamp = now.toLocaleString();

            return `// Arduino ç¨‹å¼ç¢¼
// ç”± TextBlockly è‡ªå‹•ç”Ÿæˆ
// ç”Ÿæˆæ™‚é–“: ${timestamp}

void setup() {
${formattedSetupCode}
}

void loop() {
${formattedLoopCode}
}`;
        }

        // æ ¼å¼åŒ–ç¨‹å¼ç¢¼è¡Œï¼Œç¢ºä¿æ­£ç¢ºç¸®æ’
        function formatCodeLines(code, baseIndent) {
            if (!code || code.trim() === '') {
                return baseIndent + '// è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡';
            }

            return code.split('\n')
                .map(line => {
                    const trimmed = line.trim();
                    if (trimmed === '' || trimmed.startsWith('//')) {
                        return line; // ä¿æŒè¨»è§£å’Œç©ºè¡ŒåŸæ¨£
                    }
                    // ç¢ºä¿æ¯è¡Œéƒ½æœ‰åŸºæœ¬ç¸®æ’ï¼Œé™¤éå·²ç¶“æœ‰ç¸®æ’
                    if (!line.startsWith(' ') && !line.startsWith('\t')) {
                        return baseIndent + trimmed;
                    }
                    return line;
                })
                .join('\n');
        }

        // ç”Ÿæˆç©æœ¨ç¨‹å¼ç¢¼
        function generateBlockCode(block, indent = '  ') {
            if (!block) return '  // è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡';

            let code = '';
            let currentBlock = block;

            while (currentBlock) {
                const blockCode = generateSingleBlockCode(currentBlock, indent);
                if (blockCode) {
                    code += blockCode + '\n';
                }
                currentBlock = currentBlock.getNextBlock();
            }

            return code.trim() || '  // è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡';
        }

        // ç”Ÿæˆå–®ä¸€ç©æœ¨ç¨‹å¼ç¢¼
        function generateSingleBlockCode(block, indent) {
            const blockType = block.type;

            switch (blockType) {
                // Arduino ç‰¹å®šç©æœ¨
                case 'arduino_digitalwrite':
                    const pin = validateNumber(block.getFieldValue('PIN'), '13', 0, 53);
                    const state = block.getFieldValue('STATE') || 'HIGH';
                    return `${indent}digitalWrite(${pin}, ${state});`;

                case 'arduino_digitalread':
                    const readPin = validateNumber(block.getFieldValue('PIN'), '2', 0, 53);
                    return `digitalRead(${readPin})`;

                case 'arduino_pinmode':
                    const modePin = validateNumber(block.getFieldValue('PIN'), '13', 0, 53);
                    const mode = block.getFieldValue('MODE') || 'OUTPUT';
                    return `${indent}pinMode(${modePin}, ${mode});`;

                case 'arduino_analogread':
                    const analogPin = block.getFieldValue('PIN') || 'A0';
                    // é©—è­‰é¡æ¯”è…³ä½æ ¼å¼
                    const validAnalogPin = /^A[0-5]$/.test(analogPin) ? analogPin : 'A0';
                    return `analogRead(${validAnalogPin})`;

                case 'arduino_analogwrite':
                    const pwmPin = validateNumber(block.getFieldValue('PIN'), '9', 0, 53);
                    const pwmValue = validateNumber(block.getFieldValue('VALUE'), '128', 0, 255);
                    return `${indent}analogWrite(${pwmPin}, ${pwmValue});`;

                case 'arduino_delay':
                    const delayTime = validateNumber(block.getFieldValue('TIME'), '1000', 0);
                    return `${indent}delay(${delayTime});`;

                case 'arduino_delayMicroseconds':
                    const microTime = validateNumber(block.getFieldValue('TIME'), '1000', 0, 16383);
                    return `${indent}delayMicroseconds(${microTime});`;

                // æ§åˆ¶æµç¨‹ç©æœ¨
                case 'controls_if':
                    return generateControlsIf(block, indent);

                case 'controls_repeat_ext':
                    return generateControlsRepeat(block, indent);

                case 'controls_whileUntil':
                    return generateControlsWhile(block, indent);

                case 'controls_for':
                    return generateControlsFor(block, indent);

                // é‚è¼¯ç©æœ¨
                case 'logic_compare':
                    return generateLogicCompare(block);

                case 'logic_operation':
                    return generateLogicOperation(block);

                case 'logic_negate':
                    return generateLogicNegate(block);

                case 'logic_boolean':
                    return generateLogicBoolean(block);

                // æ•¸å­¸ç©æœ¨
                case 'math_number':
                    return validateNumber(block.getFieldValue('NUM'), '0');

                case 'math_arithmetic':
                    return generateMathArithmetic(block);

                // è®Šæ•¸ç©æœ¨
                case 'variables_get':
                    return validateVariableName(block.getFieldValue('VAR'), 'variable');

                case 'variables_set':
                    return generateVariablesSet(block, indent);

                default:
                    console.warn(`Unknown block type: ${blockType}`);
                    return `${indent}// TODO: ${blockType} ç©æœ¨`;
            }
        }

        // æ§åˆ¶æµç¨‹ç©æœ¨ç”Ÿæˆå‡½æ•¸
        function generateControlsIf(block, indent) {
            const condition = generateValueCode(block.getInputTargetBlock('IF0')) || 'true';
            const doCode = generateBlockCode(block.getInputTargetBlock('DO0'), indent + '  ');
            const elseCode = generateBlockCode(block.getInputTargetBlock('ELSE'), indent + '  ');

            let code = `${indent}if (${condition}) {\n${doCode}\n${indent}}`;
            if (elseCode && elseCode.trim() !== '// è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡') {
                code += ` else {\n${elseCode}\n${indent}}`;
            }
            return code;
        }

        function generateControlsRepeat(block, indent) {
            const times = validateNumber(generateValueCode(block.getInputTargetBlock('TIMES')), '10', 0);
            const doCode = generateBlockCode(block.getInputTargetBlock('DO'), indent + '  ');

            return `${indent}for (int i = 0; i < ${times}; i++) {\n${doCode}\n${indent}}`;
        }

        function generateControlsWhile(block, indent) {
            const mode = block.getFieldValue('MODE');
            const condition = generateValueCode(block.getInputTargetBlock('BOOL')) || 'true';
            const doCode = generateBlockCode(block.getInputTargetBlock('DO'), indent + '  ');

            const whileCondition = mode === 'WHILE' ? condition : `!(${condition})`;
            return `${indent}while (${whileCondition}) {\n${doCode}\n${indent}}`;
        }

        function generateControlsFor(block, indent) {
            const variable = validateVariableName(block.getFieldValue('VAR'), 'i');
            const from = validateNumber(generateValueCode(block.getInputTargetBlock('FROM')), '1');
            const to = validateNumber(generateValueCode(block.getInputTargetBlock('TO')), '10');
            const by = validateNumber(generateValueCode(block.getInputTargetBlock('BY')), '1');
            const doCode = generateBlockCode(block.getInputTargetBlock('DO'), indent + '  ');

            return `${indent}for (int ${variable} = ${from}; ${variable} <= ${to}; ${variable} += ${by}) {\n${doCode}\n${indent}}`;
        }

        // é‚è¼¯ç©æœ¨ç”Ÿæˆå‡½æ•¸
        function generateLogicCompare(block) {
            const operator = block.getFieldValue('OP');
            const a = generateValueCode(block.getInputTargetBlock('A')) || '0';
            const b = generateValueCode(block.getInputTargetBlock('B')) || '0';

            const operators = {
                'EQ': '==', 'NEQ': '!=', 'LT': '<', 'LTE': '<=', 'GT': '>', 'GTE': '>='
            };

            return `${a} ${operators[operator] || '=='} ${b}`;
        }

        function generateLogicOperation(block) {
            const operator = block.getFieldValue('OP');
            const a = generateValueCode(block.getInputTargetBlock('A')) || 'false';
            const b = generateValueCode(block.getInputTargetBlock('B')) || 'false';

            return `${a} ${operator === 'AND' ? '&&' : '||'} ${b}`;
        }

        function generateLogicNegate(block) {
            const bool = generateValueCode(block.getInputTargetBlock('BOOL')) || 'false';
            return `!(${bool})`;
        }

        function generateLogicBoolean(block) {
            return block.getFieldValue('BOOL') === 'TRUE' ? 'true' : 'false';
        }

        // æ•¸å­¸ç©æœ¨ç”Ÿæˆå‡½æ•¸
        function generateMathArithmetic(block) {
            const operator = block.getFieldValue('OP');
            const a = generateValueCode(block.getInputTargetBlock('A')) || '0';
            const b = generateValueCode(block.getInputTargetBlock('B')) || '0';

            const operators = {
                'ADD': '+', 'MINUS': '-', 'MULTIPLY': '*', 'DIVIDE': '/', 'POWER': 'pow'
            };

            if (operator === 'POWER') {
                return `pow(${a}, ${b})`;
            }

            return `${a} ${operators[operator] || '+'} ${b}`;
        }

        // è®Šæ•¸ç©æœ¨ç”Ÿæˆå‡½æ•¸
        function generateVariablesSet(block, indent) {
            const variable = validateVariableName(block.getFieldValue('VAR'), 'variable');
            const value = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';

            return `${indent}${variable} = ${value};`;
        }

        // è¼”åŠ©å‡½æ•¸ï¼šç”Ÿæˆå€¼è¡¨é”å¼çš„ç¨‹å¼ç¢¼
        function generateValueCode(block) {
            if (!block) {
                return '';
            }
            return generateSingleBlockCode(block, '').trim();
        }

        // é©—è­‰å’Œæ¸…ç†æ•¸å€¼
        function validateNumber(value, defaultValue = '0', min = null, max = null) {
            if (value === null || value === undefined || value === '') {
                return defaultValue;
            }

            const num = parseFloat(value);
            if (isNaN(num)) {
                return defaultValue;
            }

            if (min !== null && num < min) {
                return min.toString();
            }

            if (max !== null && num > max) {
                return max.toString();
            }

            // å°æ–¼æ•´æ•¸ï¼Œç§»é™¤å°æ•¸é»
            if (Number.isInteger(num)) {
                return Math.floor(num).toString();
            }

            return num.toString();
        }

        // é©—è­‰å’Œæ¸…ç†è®Šæ•¸åç¨±
        function validateVariableName(name, defaultName = 'variable') {
            if (!name || typeof name !== 'string') {
                return defaultName;
            }

            // ç§»é™¤ç„¡æ•ˆå­—ç¬¦ï¼Œåªä¿ç•™å­—æ¯ã€æ•¸å­—å’Œåº•ç·š
            let cleanName = name.replace(/[^a-zA-Z0-9_]/g, '');

            // ç¢ºä¿ä»¥å­—æ¯æˆ–åº•ç·šé–‹å§‹
            if (cleanName && /^[0-9]/.test(cleanName)) {
                cleanName = '_' + cleanName;
            }

            // å¦‚æœæ¸…ç†å¾Œç‚ºç©ºï¼Œä½¿ç”¨é è¨­åç¨±
            if (!cleanName) {
                return defaultName;
            }

            // é¿å… Arduino é—œéµå­—
            const arduinoKeywords = ['setup', 'loop', 'void', 'int', 'float', 'char', 'byte', 'boolean', 'true', 'false', 'HIGH', 'LOW'];
            if (arduinoKeywords.includes(cleanName.toLowerCase())) {
                return '_' + cleanName;
            }

            return cleanName;
        }

        // æ‰‹å‹•åŒæ­¥ï¼šç©æœ¨åˆ°ç¨‹å¼ç¢¼
        function manualSyncToCode() {
            try {
                showLoading();
                console.log('Manual sync: blocks to code');

                // æª¢æŸ¥å·¥ä½œå€ä¸­çš„ç©æœ¨
                const allBlocks = workspace.getAllBlocks();
                console.log('Total blocks in workspace:', allBlocks.length);
                console.log('Block types:', allBlocks.map(b => b.type));

                // å¦‚æœå·¥ä½œå€æ˜¯ç©ºçš„ï¼Œè‡ªå‹•å‰µå»ºåŸºæœ¬çš„ setup å’Œ loop ç©æœ¨
                if (allBlocks.length === 0) {
                    console.log('Workspace is empty, creating default blocks');
                    createTestBlocks();
                }

                const code = generateArduinoCode();
                console.log('Generated code (full):');
                console.log(code);
                console.log('Code length:', code.length);

                if (!code || code.trim().length === 0) {
                    hideLoading();
                    showError('ç„¡æ³•ç”Ÿæˆç¨‹å¼ç¢¼ï¼šå·¥ä½œå€ç‚ºç©ºæˆ–ç©æœ¨ç„¡æ•ˆ');
                    return;
                }

                // ç™¼é€åŒæ­¥è¨Šæ¯åˆ° VSCode
                vscode.postMessage({
                    command: 'manualSyncToCode',
                    data: { code: code }
                });

                hideLoading();
                console.log('Manual sync to code completed');
            } catch (error) {
                hideLoading();
                showError('åŒæ­¥åˆ°ç¨‹å¼ç¢¼å¤±æ•—: ' + error.message);
                console.error('Manual sync to code error:', error);
            }
        }

        // æ‰‹å‹•åŒæ­¥ï¼šç¨‹å¼ç¢¼åˆ°ç©æœ¨
        function manualSyncToBlocks() {
            try {
                showLoading();
                console.log('Manual sync: code to blocks');

                // è«‹æ±‚ VSCode æä¾›ç•¶å‰ç¨‹å¼ç¢¼
                vscode.postMessage({
                    command: 'manualSyncToBlocks'
                });

                console.log('Manual sync to blocks request sent');
            } catch (error) {
                hideLoading();
                showError('åŒæ­¥åˆ°ç©æœ¨å¤±æ•—: ' + error.message);
                console.error('Manual sync to blocks error:', error);
            }
        }

        // é¡¯ç¤ºè¼‰å…¥ç‹€æ…‹
        function showLoading() {
            document.getElementById('loading').style.display = 'flex';
        }

        // éš±è—è¼‰å…¥ç‹€æ…‹
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // æ›´æ–°ç©æœ¨æ•¸é‡
        function updateBlockCount() {
            const count = workspace.getAllBlocks().length;
            document.getElementById('blockCount').textContent = count;
        }


        // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }

        // éš±è—éŒ¯èª¤è¨Šæ¯
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // å·¥å…·åˆ—æŒ‰éˆ•äº‹ä»¶
        document.getElementById('saveBtn').addEventListener('click', () => {
            let xmlText;
            try {
                if (typeof Blockly.utils !== 'undefined' && Blockly.utils.xml) {
                    // æ–°ç‰ˆ Blockly API
                    const xmlDom = Blockly.serialization.workspaces.save(workspace);
                    xmlText = Blockly.utils.xml.domToText(xmlDom);
                } else if (typeof Blockly.Xml !== 'undefined' && typeof Blockly.Xml.workspaceToDom === 'function') {
                    // èˆŠç‰ˆ Blockly API
                    const xmlDom = Blockly.Xml.workspaceToDom(workspace);
                    if (typeof Blockly.Xml.domToText === 'function') {
                        xmlText = Blockly.Xml.domToText(xmlDom);
                    } else {
                        xmlText = new XMLSerializer().serializeToString(xmlDom);
                    }
                } else {
                    xmlText = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
                }
            } catch (error) {
                console.error('Error saving template:', error);
                xmlText = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
            }

            vscode.postMessage({
                command: 'saveTemplate',
                data: { xml: xmlText }
            });
        });

        document.getElementById('loadBtn').addEventListener('click', () => {
            vscode.postMessage({ command: 'loadTemplate' });
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('ç¢ºå®šè¦æ¸…ç©ºå·¥ä½œå€å—ï¼Ÿ')) {
                workspace.clear();
            }
        });

        document.getElementById('testBtn').addEventListener('click', () => {
            console.log('Test button clicked - creating test blocks');
            createTestBlocks();
        });

        document.getElementById('syncToCodeBtn').addEventListener('click', () => {
            console.log('Sync to code button clicked');
            manualSyncToCode();
        });

        document.getElementById('syncToBlocksBtn').addEventListener('click', () => {
            console.log('Sync to blocks button clicked');
            manualSyncToBlocks();
        });


        // VSCode è¨Šæ¯è™•ç†
        window.addEventListener('message', event => {
            const message = event.data;
            console.log('Received message from VSCode:', message.command);

            switch (message.command) {
                case 'loadWorkspace':
                    if (message.data && message.data.xml) {
                        console.log('Loading workspace from XML:', message.data.xml.substring(0, 200));
                        try {
                            // æš«æ™‚ç¦ç”¨å·¥ä½œå€è®Šæ›´äº‹ä»¶ä»¥é˜²æ­¢å¾ªç’°
                            workspace.removeChangeListener(onWorkspaceChange);

                            // æ¸…ç©ºç¾æœ‰å·¥ä½œå€
                            workspace.clear();

                            // è¼‰å…¥æ–°çš„å·¥ä½œå€ - ä½¿ç”¨ä¸åŒçš„ API æ–¹æ³•
                            let xml;
                            let loadSuccess = false;

                            // å˜—è©¦æ–°ç‰ˆ Blockly APIï¼ˆä½†ä½¿ç”¨ XML è€Œä¸æ˜¯ serializationï¼‰
                            if (typeof Blockly.utils !== 'undefined' && Blockly.utils.xml) {
                                try {
                                    console.log('Trying new Blockly API (utils.xml)');
                                    xml = Blockly.utils.xml.textToDom(message.data.xml);
                                    // ä½¿ç”¨ Xml.domToWorkspace è€Œä¸æ˜¯ serialization.workspaces.load
                                    if (typeof Blockly.Xml !== 'undefined' && typeof Blockly.Xml.domToWorkspace === 'function') {
                                        Blockly.Xml.domToWorkspace(xml, workspace);
                                        loadSuccess = true;
                                        console.log('New API with domToWorkspace load successful');
                                    }
                                } catch (error) {
                                    console.log('New API failed:', error);
                                }
                            }

                            // å˜—è©¦èˆŠç‰ˆ Blockly API
                            if (!loadSuccess && typeof Blockly.Xml !== 'undefined') {
                                if (typeof Blockly.Xml.textToDom === 'function') {
                                    try {
                                        console.log('Trying old Blockly API (Xml.textToDom)');
                                        xml = Blockly.Xml.textToDom(message.data.xml);
                                        Blockly.Xml.domToWorkspace(xml, workspace);
                                        loadSuccess = true;
                                        console.log('Old API load successful');
                                    } catch (error) {
                                        console.log('Old API with textToDom failed:', error);
                                    }
                                } else if (typeof Blockly.Xml.domToWorkspace === 'function') {
                                    try {
                                        console.log('Trying DOMParser + domToWorkspace');
                                        const parser = new DOMParser();
                                        xml = parser.parseFromString(message.data.xml, 'text/xml');
                                        Blockly.Xml.domToWorkspace(xml, workspace);
                                        loadSuccess = true;
                                        console.log('DOMParser + domToWorkspace successful');
                                    } catch (error) {
                                        console.log('DOMParser + domToWorkspace failed:', error);
                                    }
                                }
                            }

                            // æœ€å¾Œçš„å‚™ç”¨æ–¹æ¡ˆ - å˜—è©¦æ›´ç°¡å–®çš„æ–¹æ³•
                            if (!loadSuccess) {
                                console.log('All standard methods failed, trying simplified approach');
                                try {
                                    // å˜—è©¦æœ€ç›´æ¥çš„æ–¹æ³•
                                    const parser = new DOMParser();
                                    const xmlDoc = parser.parseFromString(message.data.xml, 'text/xml');
                                    const xmlElement = xmlDoc.documentElement;

                                    if (typeof Blockly.Xml.domToWorkspace === 'function') {
                                        Blockly.Xml.domToWorkspace(xmlElement, workspace);
                                        loadSuccess = true;
                                        console.log('Simplified domToWorkspace successful');
                                    }
                                } catch (error) {
                                    console.error('Simplified approach failed:', error);
                                    console.log('XML that failed to load:', message.data.xml);
                                }
                            }

                            // é‡æ–°å•Ÿç”¨è®Šæ›´äº‹ä»¶
                            setTimeout(() => {
                                workspace.addChangeListener(onWorkspaceChange);
                            }, 100);

                            console.log('Workspace loaded successfully');
                            // éš±è—è¼‰å…¥ç‹€æ…‹
                            hideLoading();
                        } catch (error) {
                            console.error('Failed to load workspace:', error);
                            showError('è¼‰å…¥å·¥ä½œå€å¤±æ•—: ' + error.message);
                            hideLoading();
                        }
                    }
                    break;
                case 'syncCode':
                    generateCode();
                    break;
            }
        });

        // æ‰‹å‹•å¾ XML å‰µå»ºç©æœ¨ï¼ˆå‚™ç”¨æ–¹æ¡ˆï¼‰
        function createBlocksFromXml(xmlDoc) {
            console.log('Creating blocks manually from XML');

            const blocks = xmlDoc.getElementsByTagName('block');
            console.log('Found', blocks.length, 'blocks in XML');

            for (let i = 0; i < blocks.length; i++) {
                const blockElement = blocks[i];
                const blockType = blockElement.getAttribute('type');
                console.log('Processing block type:', blockType);

                if (blockType === 'arduino_setup' || blockType === 'arduino_loop') {
                    console.log('Creating', blockType, 'block');

                    try {
                        // æª¢æŸ¥ç©æœ¨é¡å‹æ˜¯å¦å­˜åœ¨
                        if (!Blockly.Blocks[blockType]) {
                            console.error('Block type not found:', blockType);
                            console.log('Available block types:', Object.keys(Blockly.Blocks));
                            continue;
                        }

                        // å‰µå»ºç©æœ¨
                        const block = workspace.newBlock(blockType);
                        console.log('Block created:', block);

                        // è¨­ç½®ä½ç½®
                        const x = parseInt(blockElement.getAttribute('x')) || (blockType === 'arduino_setup' ? 50 : 50);
                        const y = parseInt(blockElement.getAttribute('y')) || (blockType === 'arduino_setup' ? 50 : 250);
                        console.log('Moving block to position:', x, y);
                        block.moveBy(x, y);

                        // åˆå§‹åŒ–ä¸¦æ¸²æŸ“ç©æœ¨
                        block.initSvg();
                        block.render();
                        console.log('Block rendered successfully');
                    } catch (error) {
                        console.error('Error creating block:', blockType, error);
                    }
                }
            }

            console.log('Manual block creation completed');
            console.log('Total blocks in workspace:', workspace.getAllBlocks().length);
        }

        // æ‰‹å‹•å‰µå»ºå…©å€‹åŸºæœ¬ç©æœ¨ä¾†æ¸¬è©¦é¡¯ç¤º
        function createTestBlocks() {
            console.log('Creating test blocks manually');

            try {
                // å‰µå»º setup ç©æœ¨
                const setupBlock = workspace.newBlock('arduino_setup');
                setupBlock.moveBy(50, 50);
                setupBlock.initSvg();
                setupBlock.render();
                console.log('Setup block created');

                // å‰µå»º loop ç©æœ¨
                const loopBlock = workspace.newBlock('arduino_loop');
                loopBlock.moveBy(50, 250);
                loopBlock.initSvg();
                loopBlock.render();
                console.log('Loop block created');

                console.log('Test blocks created successfully');
                console.log('Total blocks in workspace:', workspace.getAllBlocks().length);
            } catch (error) {
                console.error('Error creating test blocks:', error);
                console.log('Available block types:', Object.keys(Blockly.Blocks));
            }
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', initBlockly);
    </script>
</body>
</html>