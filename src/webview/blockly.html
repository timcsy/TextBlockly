<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TextBlockly - Arduino Visual Programming</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);
        }

        .container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        .toolbar {
            background-color: var(--vscode-titleBar-activeBackground);
            color: var(--vscode-titleBar-activeForeground);
            padding: 8px 16px;
            border-bottom: 1px solid var(--vscode-panel-border);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toolbar button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .toolbar button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }

        .toolbar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .blockly-area {
            flex: 1;
            position: relative;
        }

        #blocklyDiv {
            height: 100%;
            width: 100%;
        }

        .status-bar {
            background-color: var(--vscode-statusBar-background);
            color: var(--vscode-statusBar-foreground);
            padding: 4px 16px;
            font-size: 11px;
            border-top: 1px solid var(--vscode-panel-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .loading {
            display: none;
            align-items: center;
            gap: 8px;
        }

        .spinner {
            width: 12px;
            height: 12px;
            border: 2px solid transparent;
            border-top: 2px solid var(--vscode-progressBar-background);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background-color: var(--vscode-inputValidation-errorBackground);
            color: var(--vscode-inputValidation-errorForeground);
            border: 1px solid var(--vscode-inputValidation-errorBorder);
            padding: 8px 12px;
            margin: 8px;
            border-radius: 4px;
            display: none;
        }

        /* ä¿®æ­£ Blockly å·¥å…·ç®±æ¨™é¡Œé¡è‰² */
        .blocklyTreeLabel,
        .goog-tree-item-label {
            color: var(--vscode-sideBarTitle-foreground, var(--vscode-foreground)) !important;
            font-weight: 600;
            text-shadow: 0 0 1px rgba(0, 0, 0, 0.5);
        }

        /* ä¿®æ­£å·¥å…·ç®±èƒŒæ™¯å’Œé‚Šæ¡† */
        .blocklyToolboxDiv {
            background-color: var(--vscode-sideBar-background) !important;
            border-right: 1px solid var(--vscode-sideBar-border) !important;
        }

        /* ç‚ºå·¥å…·ç®±é …ç›®æ·»åŠ æ›´å¥½çš„å°æ¯”åº¦ */
        .blocklyTreeRow {
            background-color: rgba(255, 255, 255, 0.05) !important;
            margin: 2px 4px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* ä¿®æ­£é£›å‡ºé¸å–®èƒŒæ™¯ */
        .blocklyFlyout {
            background-color: var(--vscode-sideBar-background) !important;
        }

        /* ä¿®æ­£åˆ†é¡é¸ä¸­ç‹€æ…‹ */
        .blocklyTreeRow.blocklyTreeRowSelected {
            background-color: var(--vscode-list-activeSelectionBackground) !important;
        }

        .blocklyTreeRow.blocklyTreeRowSelected .blocklyTreeLabel {
            color: var(--vscode-list-activeSelectionForeground) !important;
        }

        /* ä¿®æ­£åˆ†é¡æ‡¸åœç‹€æ…‹ */
        .blocklyTreeRow:hover {
            background-color: var(--vscode-list-hoverBackground) !important;
        }

        .blocklyTreeRow:hover .blocklyTreeLabel {
            color: var(--vscode-list-hoverForeground) !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å·¥å…·åˆ— -->
        <div class="toolbar">
            <button id="saveBtn" title="å„²å­˜ç‚ºæ¨¡æ¿">ğŸ’¾ å„²å­˜</button>
            <button id="loadBtn" title="è¼‰å…¥æ¨¡æ¿">ğŸ“‚ è¼‰å…¥</button>
            <button id="clearBtn" title="æ¸…ç©ºå·¥ä½œå€">ğŸ—‘ï¸ æ¸…ç©º</button>
            <div style="border-left: 1px solid var(--vscode-panel-border); margin: 0 8px; height: 20px;"></div>
            <button id="syncToCodeBtn" title="å°‡ç©æœ¨åŒæ­¥åˆ°ç¨‹å¼ç¢¼">ğŸ”„ åŒæ­¥åˆ°ç¨‹å¼ç¢¼</button>
            <button id="syncToBlocksBtn" title="å°‡ç¨‹å¼ç¢¼åŒæ­¥åˆ°ç©æœ¨">ğŸ”ƒ åŒæ­¥åˆ°ç©æœ¨</button>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <span>åŒæ­¥ä¸­...</span>
            </div>
        </div>

        <!-- éŒ¯èª¤è¨Šæ¯ -->
        <div class="error-message" id="errorMessage"></div>

        <!-- ä¸»è¦å…§å®¹å€åŸŸ -->
        <div class="main-content">
            <!-- Blockly å·¥ä½œå€ -->
            <div class="blockly-area">
                <div id="blocklyDiv"></div>
            </div>
        </div>

        <!-- ç‹€æ…‹åˆ— -->
        <div class="status-bar">
            <div class="status-item">
                <span>ç©æœ¨æ•¸é‡: </span>
                <span id="blockCount">0</span>
            </div>
            <div class="status-item">
                <span id="syncStatus">å°±ç·’ - ç¨‹å¼ç¢¼å³æ™‚åŒæ­¥åˆ°å³å´ç·¨è¼¯å™¨</span>
            </div>
        </div>
    </div>

    <!-- Blockly æ ¸å¿ƒåº« -->
    <script src="{{BLOCKLY_PATH}}/blockly_compressed.js"></script>
    <script src="{{BLOCKLY_PATH}}/blocks_compressed.js"></script>
    <script src="{{BLOCKLY_PATH}}/msg/zh-hant.js"></script>

    <script>
        // å…¨åŸŸè®Šæ•¸
        let workspace;
        let vscode;
        let codeGenerationTimer;

        // VSCode API
        if (typeof acquireVsCodeApi !== 'undefined') {
            vscode = acquireVsCodeApi();
        } else {
            // é–‹ç™¼ç’°å¢ƒæ¨¡æ“¬
            vscode = {
                postMessage: (message) => console.log('VSCode Message:', message),
                getState: () => null,
                setState: (state) => console.log('VSCode State:', state)
            };
        }

        // Arduino ç©æœ¨å®šç¾©
        const ARDUINO_BLOCKS = {{ARDUINO_BLOCKS}};

        // å·¥å…·ç®±é…ç½®
        const TOOLBOX = {{TOOLBOX}};

        // è®Šæ•¸è¨ˆæ•¸å™¨ç”¨æ–¼ç”Ÿæˆé è¨­åç¨±
        let variableCounter = 1;

        // å…¨å±€è¦†è“‹ prompt å‡½æ•¸ä»¥é¡¯ç¤ºè‡ªå®šç¾©å°è©±æ¡†
        window.prompt = function(message, defaultValue) {
            console.log('ğŸ”¥ PROMPT INTERCEPTED:', {
                message: message,
                defaultValue: defaultValue,
                timestamp: new Date().toISOString()
            });

            // æª¢æŸ¥æ˜¯å¦ç‚ºè®Šæ•¸å‰µå»ºç›¸é—œçš„æç¤º
            if (message && (message.includes('variable') || message.includes('è®Šæ•¸') || message.includes('name') ||
                           message.includes('Create') || message.includes('New'))) {

                // ç”Ÿæˆé è¨­è®Šæ•¸åç¨±
                const suggestedName = defaultValue || `variable${variableCounter}`;
                variableCounter++;

                console.log('ğŸ¯ Variable creation detected:', {
                    suggestedName: suggestedName,
                    counter: variableCounter,
                    workspaceAvailable: !!workspace
                });

                // é¡¯ç¤ºç•°æ­¥å°è©±æ¡†ï¼Œå¦‚æœç”¨æˆ¶æ›´æ”¹åç¨±ï¼Œå‰‡æ›´æ–°è®Šæ•¸
                setTimeout(() => {
                    console.log('â° Starting async dialog for variable:', suggestedName);

                    showVariableNameDialogAsync(message, suggestedName, (userResult) => {
                        console.log('ğŸ“¨ Async dialog callback received:', {
                            userResult: userResult,
                            originalName: suggestedName,
                            changed: userResult !== suggestedName
                        });

                        if (userResult && userResult !== suggestedName && workspace && workspace.createVariable) {
                            console.log('ğŸ”„ User changed variable name, attempting replacement...');

                            try {
                                // å…ˆæŸ¥æ‰¾é è¨­è®Šæ•¸
                                const allVars = workspace.getAllVariables();
                                console.log('ğŸ“‹ Current variables:', allVars.map(v => v.name));

                                const defaultVar = workspace.getVariable(suggestedName);
                                if (defaultVar) {
                                    console.log('ğŸ—‘ï¸ Deleting default variable:', suggestedName);
                                    workspace.deleteVariableById(defaultVar.getId());
                                } else {
                                    console.log('âš ï¸ Default variable not found:', suggestedName);
                                }

                                // å‰µå»ºç”¨æˆ¶æŒ‡å®šçš„è®Šæ•¸
                                console.log('â• Creating user variable:', userResult);
                                const newVar = workspace.createVariable(userResult, null, userResult);
                                console.log('âœ… Successfully created user variable:', {
                                    name: newVar.name,
                                    id: newVar.getId()
                                });

                                // åˆ·æ–°å·¥å…·ç®±ä»¥æ›´æ–°è®Šæ•¸åˆ—è¡¨
                                if (workspace.refreshToolboxSelection) {
                                    workspace.refreshToolboxSelection();
                                }

                            } catch (error) {
                                console.error('âŒ Error updating variable name:', error);
                            }
                        } else if (!userResult) {
                            console.log('âŒ User cancelled variable creation');
                        } else if (userResult === suggestedName) {
                            console.log('ğŸ“ User kept the suggested name:', suggestedName);
                        } else if (!workspace) {
                            console.error('âŒ Workspace not available for variable update');
                        }
                    });
                }, 150); // å¢åŠ å»¶é²ä»¥ç¢ºä¿ Blockly å®Œå…¨åˆå§‹åŒ–

                // ç«‹å³è¿”å›é è¨­åç¨±çµ¦ Blockly
                console.log('ğŸ“¤ Returning default name to Blockly:', suggestedName);
                return suggestedName;
            }

            // å°æ–¼å…¶ä»–æç¤ºï¼Œè¿”å›é»˜èªå€¼æˆ–ç©ºå­—ç¬¦ä¸²
            console.log('â“ Non-variable prompt, returning default:', defaultValue || '');
            return defaultValue || '';
        };

        // åˆå§‹åŒ– Blockly
        function initBlockly() {
            try {
                // è¨»å†Š Arduino ç©æœ¨
                registerArduinoBlocks();

                // å‰µå»ºå·¥ä½œå€
                workspace = Blockly.inject('blocklyDiv', {
                    toolbox: TOOLBOX,
                    grid: {
                        spacing: 20,
                        length: 3,
                        colour: '#ccc',
                        snap: true
                    },
                    zoom: {
                        controls: true,
                        wheel: true,
                        startScale: 1.0,
                        maxScale: 3,
                        minScale: 0.3,
                        scaleSpeed: 1.2
                    },
                    trashcan: true,
                    theme: Blockly.Themes.Classic
                });

                // ç›£è½å·¥ä½œå€è®Šæ›´
                workspace.addChangeListener(onWorkspaceChange);

                // åˆå§‹åŒ–è®Šæ•¸ç³»çµ± - å‰µå»ºé è¨­è®Šæ•¸ä»¥å•Ÿç”¨è®Šæ•¸åŠŸèƒ½
                console.log('ğŸ”§ Initializing variable system...');
                if (workspace.createVariable) {
                    workspace.createVariable('item', null, 'item');
                    console.log('âœ… Created default variable: item');
                } else {
                    console.warn('âŒ workspace.createVariable not available');
                }

                // æª¢æŸ¥è®Šæ•¸ç®¡ç†ç³»çµ±
                if (Blockly.Variables) {
                    console.log('âœ… Blockly.Variables is available');
                    console.log('Variables methods:', Object.keys(Blockly.Variables));
                } else {
                    console.warn('âŒ Blockly.Variables not available');
                }

                // æª¢æŸ¥å·¥å…·ç®±ä¸­çš„è®Šæ•¸é¡åˆ¥
                console.log('ğŸ“Š Checking variable category in toolbox...');
                const toolboxXml = workspace.getToolbox();
                if (toolboxXml) {
                    console.log('âœ… Toolbox found');
                } else {
                    console.warn('âŒ No toolbox found');
                }

                console.log('âœ… Variable creation will be handled by global prompt() override');

                // æ‰‹å‹•åŒæ­¥æ¨¡å¼ - ä¸è‡ªå‹•ç”Ÿæˆç¨‹å¼ç¢¼
                console.log('Blockly initialized in manual sync mode');

                // é€šçŸ¥ VSCode Blockly å·²æº–å‚™å°±ç·’
                vscode.postMessage({
                    command: 'blocklyReady',
                    data: { blockCount: workspace.getAllBlocks().length }
                });

                console.log('Blockly åˆå§‹åŒ–æˆåŠŸï¼Œå·²é€šçŸ¥ VSCode');
            } catch (error) {
                showError('Blockly åˆå§‹åŒ–å¤±æ•—: ' + error.message);
                console.error('Blockly åˆå§‹åŒ–éŒ¯èª¤:', error);
            }
        }

        // è¨»å†Š Arduino ç©æœ¨
        function registerArduinoBlocks() {
            ARDUINO_BLOCKS.forEach(block => {
                Blockly.Blocks[block.type] = {
                    init: function() {
                        this.jsonInit(block);
                    }
                };
            });

            // è¨»å†Šæ¨™æº– Blockly é‚è¼¯ç©æœ¨
            if (!Blockly.Blocks['logic_compare']) {
                Blockly.Blocks['logic_compare'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'logic_compare',
                            message0: '%1 %2 %3',
                            args0: [
                                { type: 'input_value', name: 'A', check: null },
                                {
                                    type: 'field_dropdown',
                                    name: 'OP',
                                    options: [
                                        ['=', 'EQ'],
                                        ['â‰ ', 'NEQ'],
                                        ['<', 'LT'],
                                        ['â‰¤', 'LTE'],
                                        ['>', 'GT'],
                                        ['â‰¥', 'GTE']
                                    ]
                                },
                                { type: 'input_value', name: 'B', check: null }
                            ],
                            inputsInline: true,
                            output: 'Boolean',
                            colour: 210,
                            tooltip: 'æ¯”è¼ƒå…©å€‹å€¼',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['logic_operation']) {
                Blockly.Blocks['logic_operation'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'logic_operation',
                            message0: '%1 %2 %3',
                            args0: [
                                { type: 'input_value', name: 'A', check: 'Boolean' },
                                {
                                    type: 'field_dropdown',
                                    name: 'OP',
                                    options: [
                                        ['ä¸”', 'AND'],
                                        ['æˆ–', 'OR']
                                    ]
                                },
                                { type: 'input_value', name: 'B', check: 'Boolean' }
                            ],
                            inputsInline: true,
                            output: 'Boolean',
                            colour: 210,
                            tooltip: 'é‚è¼¯é‹ç®—',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['logic_negate']) {
                Blockly.Blocks['logic_negate'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'logic_negate',
                            message0: 'ä¸æ˜¯ %1',
                            args0: [
                                { type: 'input_value', name: 'BOOL', check: 'Boolean' }
                            ],
                            output: 'Boolean',
                            colour: 210,
                            tooltip: 'é‚è¼¯å¦å®š',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['logic_boolean']) {
                Blockly.Blocks['logic_boolean'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'logic_boolean',
                            message0: '%1',
                            args0: [
                                {
                                    type: 'field_dropdown',
                                    name: 'BOOL',
                                    options: [
                                        ['çœŸ', 'TRUE'],
                                        ['å‡', 'FALSE']
                                    ]
                                }
                            ],
                            output: 'Boolean',
                            colour: 210,
                            tooltip: 'å¸ƒæ—å€¼',
                            helpUrl: ''
                        });
                    }
                };
            }

            // è¨»å†Šæ§åˆ¶æµç©æœ¨
            if (!Blockly.Blocks['controls_if']) {
                Blockly.Blocks['controls_if'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'controls_if',
                            message0: 'å¦‚æœ %1',
                            message1: 'åŸ·è¡Œ %1',
                            args0: [
                                { type: 'input_value', name: 'IF0', check: 'Boolean' }
                            ],
                            args1: [
                                { type: 'input_statement', name: 'DO0' }
                            ],
                            previousStatement: null,
                            nextStatement: null,
                            colour: 210,
                            tooltip: 'å¦‚æœæ¢ä»¶ç‚ºçœŸï¼ŒåŸ·è¡Œèªå¥',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['controls_repeat_ext']) {
                Blockly.Blocks['controls_repeat_ext'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'controls_repeat_ext',
                            message0: 'é‡è¤‡ %1 æ¬¡',
                            message1: 'åŸ·è¡Œ %1',
                            args0: [
                                { type: 'input_value', name: 'TIMES', check: 'Number' }
                            ],
                            args1: [
                                { type: 'input_statement', name: 'DO' }
                            ],
                            previousStatement: null,
                            nextStatement: null,
                            colour: 120,
                            tooltip: 'é‡è¤‡åŸ·è¡ŒæŒ‡å®šæ¬¡æ•¸',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['controls_whileUntil']) {
                Blockly.Blocks['controls_whileUntil'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'controls_whileUntil',
                            message0: '%1 %2',
                            message1: 'åŸ·è¡Œ %1',
                            args0: [
                                {
                                    type: 'field_dropdown',
                                    name: 'MODE',
                                    options: [
                                        ['ç•¶', 'WHILE'],
                                        ['ç›´åˆ°', 'UNTIL']
                                    ]
                                },
                                { type: 'input_value', name: 'BOOL', check: 'Boolean' }
                            ],
                            args1: [
                                { type: 'input_statement', name: 'DO' }
                            ],
                            previousStatement: null,
                            nextStatement: null,
                            colour: 120,
                            tooltip: 'æ¢ä»¶è¿´åœˆ',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['controls_for']) {
                Blockly.Blocks['controls_for'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'controls_for',
                            message0: 'è¨ˆæ•¸ %1 å¾ %2 åˆ° %3 æ¯æ¬¡å¢åŠ  %4',
                            message1: 'åŸ·è¡Œ %1',
                            args0: [
                                { type: 'field_variable', name: 'VAR', variable: 'i' },
                                { type: 'input_value', name: 'FROM', check: 'Number' },
                                { type: 'input_value', name: 'TO', check: 'Number' },
                                { type: 'input_value', name: 'BY', check: 'Number' }
                            ],
                            args1: [
                                { type: 'input_statement', name: 'DO' }
                            ],
                            inputsInline: true,
                            previousStatement: null,
                            nextStatement: null,
                            colour: 120,
                            tooltip: 'for è¿´åœˆ',
                            helpUrl: ''
                        });
                    }
                };
            }

            // è¨»å†Šæ•¸å­¸ç©æœ¨
            if (!Blockly.Blocks['math_number']) {
                Blockly.Blocks['math_number'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'math_number',
                            message0: '%1',
                            args0: [
                                { type: 'field_number', name: 'NUM', value: 0 }
                            ],
                            output: 'Number',
                            colour: 230,
                            tooltip: 'æ•¸å­—',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['math_arithmetic']) {
                Blockly.Blocks['math_arithmetic'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'math_arithmetic',
                            message0: '%1 %2 %3',
                            args0: [
                                { type: 'input_value', name: 'A', check: 'Number' },
                                {
                                    type: 'field_dropdown',
                                    name: 'OP',
                                    options: [
                                        ['+', 'ADD'],
                                        ['-', 'MINUS'],
                                        ['Ã—', 'MULTIPLY'],
                                        ['Ã·', 'DIVIDE'],
                                        ['^', 'POWER']
                                    ]
                                },
                                { type: 'input_value', name: 'B', check: 'Number' }
                            ],
                            inputsInline: true,
                            output: 'Number',
                            colour: 230,
                            tooltip: 'æ•¸å­¸é‹ç®—',
                            helpUrl: ''
                        });
                    }
                };
            }

            // è¨»å†ŠåŸºæœ¬æ–‡å­—ç©æœ¨
            if (!Blockly.Blocks['text']) {
                Blockly.Blocks['text'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'text',
                            message0: '%1',
                            args0: [
                                { type: 'field_input', name: 'TEXT', text: '' }
                            ],
                            output: 'String',
                            colour: 160,
                            tooltip: 'æ–‡å­—',
                            helpUrl: ''
                        });
                    }
                };
            }

            // Arduino ç©æœ¨ç”± ArduinoBlocks.ts è‡ªå‹•è¨»å†Š




            // è®Šæ•¸ç©æœ¨ç”± ArduinoBlocks.ts è‡ªå‹•è¨»å†Š

        }


        // é¡¯ç¤ºè®Šæ•¸åç¨±è¼¸å…¥å°è©±æ¡†ï¼ˆç•°æ­¥ç‰ˆæœ¬ï¼‰
        function showVariableNameDialogAsync(message, suggestedName, callback) {
            console.log('ğŸ¨ Creating async variable dialog:', message, suggestedName);
            // å‰µå»ºå°è©±æ¡†å…ƒç´ 
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 999999;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #2d2d30;
                border: 2px solid #007acc;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                min-width: 320px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            `;

            const title = document.createElement('h3');
            title.textContent = message || 'å»ºç«‹æ–°è®Šæ•¸';
            title.style.cssText = 'margin: 0 0 15px 0; color: #ffffff; font-size: 18px;';

            const description = document.createElement('p');
            description.textContent = 'è«‹è¼¸å…¥è®Šæ•¸åç¨±ï¼š';
            description.style.cssText = 'margin: 0 0 10px 0; color: #cccccc; font-size: 14px;';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = suggestedName;
            input.placeholder = 'è®Šæ•¸åç¨±...';
            input.style.cssText = `
                width: 100%;
                padding: 10px;
                border: 2px solid #007acc;
                border-radius: 4px;
                font-size: 14px;
                margin-bottom: 20px;
                box-sizing: border-box;
                outline: none;
                background: #1e1e1e;
                color: #ffffff;
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'å–æ¶ˆ';
            cancelButton.style.cssText = `
                padding: 10px 20px;
                border: 2px solid #666;
                background: #3c3c3c;
                color: #ffffff;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            `;

            const confirmButton = document.createElement('button');
            confirmButton.textContent = 'å»ºç«‹';
            confirmButton.style.cssText = `
                padding: 10px 20px;
                border: 2px solid #007acc;
                background: #007acc;
                color: #ffffff;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            `;

            // ç•°æ­¥äº‹ä»¶è™•ç†
            function closeDialog(returnValue) {
                console.log('ğŸšª Async dialog closing with result:', returnValue);
                try {
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                        console.log('ğŸ—‘ï¸ Async dialog removed from DOM');
                    }
                } catch (e) {
                    console.warn('Error removing async dialog from DOM:', e);
                }
                // èª¿ç”¨å›èª¿å‡½æ•¸
                callback(returnValue);
            }

            cancelButton.addEventListener('click', () => {
                closeDialog(null);
            });

            confirmButton.addEventListener('click', () => {
                const variableName = input.value.trim();
                closeDialog(variableName || null);
            });

            // éµç›¤äº‹ä»¶
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    confirmButton.click();
                } else if (e.key === 'Escape') {
                    cancelButton.click();
                }
            });

            // çµ„è£å°è©±æ¡†
            buttonContainer.appendChild(cancelButton);
            buttonContainer.appendChild(confirmButton);

            dialog.appendChild(title);
            dialog.appendChild(description);
            dialog.appendChild(input);
            dialog.appendChild(buttonContainer);

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            console.log('ğŸ“± Async dialog added to DOM');

            // èšç„¦è¼¸å…¥æ¡†ä¸¦é¸ä¸­æ–‡å­—
            setTimeout(() => {
                input.focus();
                input.select();
                console.log('ğŸ¯ Async dialog input focused');
            }, 50);

            // é»æ“Šè¦†è“‹å±¤é—œé–‰
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeDialog(null);
                }
            });
        }

        // å·¥ä½œå€è®Šæ›´äº‹ä»¶ï¼ˆæ‰‹å‹•åŒæ­¥æ¨¡å¼ - åƒ…æ›´æ–°è¨ˆæ•¸ï¼‰
        function onWorkspaceChange(event) {
            console.log('Workspace change event:', event.type);

            // åƒ…æ›´æ–°ç©æœ¨æ•¸é‡ï¼Œä¸è‡ªå‹•åŒæ­¥
            updateBlockCount();

            // æ‰‹å‹•åŒæ­¥æ¨¡å¼ - ä¸è‡ªå‹•ç”Ÿæˆç¨‹å¼ç¢¼æˆ–ç™¼é€è®Šæ›´é€šçŸ¥
            console.log('Manual sync mode - auto sync disabled');
        }

        // ç”Ÿæˆç¨‹å¼ç¢¼
        function generateCode() {
            try {
                console.log('generateCode called');
                const code = generateArduinoCode();
                console.log('Generated code:', code.substring(0, 100));

                // æ™ºèƒ½å³æ™‚åŒæ­¥åˆ°å³å´ç·¨è¼¯å™¨
                console.log('Sending smartSyncCode message to VSCode');
                vscode.postMessage({
                    command: 'smartSyncCode',
                    data: { code: code }
                });

                hideError();
            } catch (error) {
                showError('ç¨‹å¼ç¢¼ç”Ÿæˆå¤±æ•—: ' + error.message);
                console.error('ç¨‹å¼ç¢¼ç”ŸæˆéŒ¯èª¤:', error);
            }
        }

        // ç”Ÿæˆ Arduino ç¨‹å¼ç¢¼
        function generateArduinoCode() {
            const setupBlocks = workspace.getBlocksByType('arduino_setup');
            const loopBlocks = workspace.getBlocksByType('arduino_loop');

            // æ”¶é›†å…¨åŸŸè®Šæ•¸å®šç¾© - åªæ”¶é›†ä¸åœ¨ setup æˆ– loop å‡½æ•¸å…§çš„è®Šæ•¸
            const allVarBlocks = workspace.getBlocksByType('variables_define');
            const globalVarBlocks = allVarBlocks.filter(block => {
                // æª¢æŸ¥è®Šæ•¸æ˜¯å¦åœ¨ setup æˆ– loop å‡½æ•¸å…§
                let parentBlock = block.getParent();
                while (parentBlock) {
                    if (parentBlock.type === 'arduino_setup' || parentBlock.type === 'arduino_loop') {
                        return false; // åœ¨å‡½æ•¸å…§ï¼Œä¸æ˜¯å…¨åŸŸè®Šæ•¸
                    }
                    parentBlock = parentBlock.getParent();
                }
                return true; // ä¸åœ¨å‡½æ•¸å…§ï¼Œæ˜¯å…¨åŸŸè®Šæ•¸
            });

            let globalVarCode = '';
            if (globalVarBlocks.length > 0) {
                globalVarCode = globalVarBlocks.map(block => generateSingleBlockCode(block, '')).join('\n') + '\n';
            }

            let setupCode = '  // åˆå§‹åŒ–ç¨‹å¼ç¢¼';
            let loopCode = '  // ä¸»è¦ç¨‹å¼é‚è¼¯';

            if (setupBlocks.length > 0) {
                const generatedSetup = generateBlockCode(setupBlocks[0].getInputTargetBlock('SETUP_CODE'), '  ');
                if (generatedSetup && generatedSetup.trim() !== '// è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡') {
                    setupCode = generatedSetup;
                }
            }

            if (loopBlocks.length > 0) {
                const generatedLoop = generateBlockCode(loopBlocks[0].getInputTargetBlock('LOOP_CODE'), '  ');
                if (generatedLoop && generatedLoop.trim() !== '// è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡') {
                    loopCode = generatedLoop;
                }
            }

            // ç¢ºä¿ç¨‹å¼ç¢¼æœ‰æ­£ç¢ºçš„ç¸®æ’
            const formattedSetupCode = formatCodeLines(setupCode, '  ');
            const formattedLoopCode = formatCodeLines(loopCode, '  ');

            // ç”Ÿæˆæ™‚é–“æˆ³
            const now = new Date();
            const timestamp = now.toLocaleString();

            return `// Arduino ç¨‹å¼ç¢¼
// ç”± TextBlockly è‡ªå‹•ç”Ÿæˆ
// ç”Ÿæˆæ™‚é–“: ${timestamp}

${globalVarCode}void setup() {
${formattedSetupCode}
}

void loop() {
${formattedLoopCode}
}`;
        }

        // æ ¼å¼åŒ–ç¨‹å¼ç¢¼è¡Œï¼Œç¢ºä¿æ­£ç¢ºç¸®æ’
        function formatCodeLines(code, baseIndent) {
            if (!code || code.trim() === '') {
                return baseIndent + '// è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡';
            }

            return code.split('\n')
                .map(line => {
                    const trimmed = line.trim();
                    if (trimmed === '' || trimmed.startsWith('//')) {
                        return line; // ä¿æŒè¨»è§£å’Œç©ºè¡ŒåŸæ¨£
                    }
                    // ç¢ºä¿æ¯è¡Œéƒ½æœ‰åŸºæœ¬ç¸®æ’ï¼Œé™¤éå·²ç¶“æœ‰ç¸®æ’
                    if (!line.startsWith(' ') && !line.startsWith('\t')) {
                        return baseIndent + trimmed;
                    }
                    return line;
                })
                .join('\n');
        }

        // ç”Ÿæˆç©æœ¨ç¨‹å¼ç¢¼
        function generateBlockCode(block, indent = '  ') {
            if (!block) return '  // è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡';

            let code = '';
            let currentBlock = block;

            while (currentBlock) {
                const blockCode = generateSingleBlockCode(currentBlock, indent);
                if (blockCode) {
                    code += blockCode + '\n';
                }
                currentBlock = currentBlock.getNextBlock();
            }

            return code.trim() || '  // è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡';
        }

        // ç”Ÿæˆå–®ä¸€ç©æœ¨ç¨‹å¼ç¢¼
        function generateSingleBlockCode(block, indent) {
            const blockType = block.type;

            switch (blockType) {
                // Arduino ç‰¹å®šç©æœ¨
                case 'arduino_digitalwrite':
                    const pin = generateValueCode(block.getInputTargetBlock('PIN')) || '13';
                    const state = block.getFieldValue('STATE') || 'HIGH';
                    return `${indent}digitalWrite(${pin}, ${state});`;

                case 'arduino_digitalread':
                    const readPin = generateValueCode(block.getInputTargetBlock('PIN')) || '2';
                    return `digitalRead(${readPin})`;

                case 'arduino_pinmode':
                    const modePin = generateValueCode(block.getInputTargetBlock('PIN')) || '13';
                    const pinMode = block.getFieldValue('MODE') || 'OUTPUT';
                    return `${indent}pinMode(${modePin}, ${pinMode});`;

                case 'arduino_analogread':
                    const analogPin = generateValueCode(block.getInputTargetBlock('PIN')) || 'A0';
                    return `analogRead(${analogPin})`;

                case 'arduino_analogwrite':
                    const pwmPin = generateValueCode(block.getInputTargetBlock('PIN')) || '9';
                    const pwmValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '128';
                    return `${indent}analogWrite(${pwmPin}, ${pwmValue});`;

                case 'arduino_pin':
                    return block.getFieldValue('PIN') || 'A0';

                case 'arduino_raw_statement':
                    const rawStatement = block.getFieldValue('CODE') || '';
                    // æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰åˆ†è™Ÿçµå°¾ï¼Œé¿å…é‡è¤‡æ·»åŠ 
                    const trimmedStatement = rawStatement.trim();
                    if (trimmedStatement.endsWith(';') || trimmedStatement.endsWith('}') || trimmedStatement === '') {
                        return `${indent}${rawStatement}`;
                    }
                    return `${indent}${rawStatement};`;

                case 'arduino_raw_expression':
                    const rawExpression = block.getFieldValue('CODE') || '';
                    return rawExpression;

                case 'arduino_raw_block':
                    const rawBlockCode = block.getFieldValue('CODE') || '';
                    const statements = generateStatements(block, 'STATEMENTS', indent + '  ');
                    return `${indent}${rawBlockCode} {\n${statements}${indent}}`;

                case 'arduino_delay':
                    const delayTime = validateNumber(block.getFieldValue('TIME'), '1000', 0);
                    return `${indent}delay(${delayTime});`;

                case 'arduino_delayMicroseconds':
                    const microTime = validateNumber(block.getFieldValue('TIME'), '1000', 0, 16383);
                    return `${indent}delayMicroseconds(${microTime});`;

                // Serial é€šè¨Šç©æœ¨
                case 'arduino_serial_begin':
                    const baudRate = generateValueCode(block.getInputTargetBlock('BAUD')) || '9600';
                    return `${indent}Serial.begin(${baudRate});`;

                case 'arduino_serial_print':
                    const mode = block.getFieldValue('MODE') || 'PRINT';
                    const text = generateValueCode(block.getInputTargetBlock('TEXT')) || '""';
                    const methodName = mode === 'PRINTLN' ? 'println' : 'print';
                    return `${indent}Serial.${methodName}(${text});`;

                case 'arduino_serial_available':
                    return 'Serial.available()';

                case 'arduino_serial_read':
                    return 'Serial.read()';

                case 'arduino_serial_read_string':
                    return 'Serial.readString()';

                // Arduino æ•¸å­¸å‡½æ•¸ç©æœ¨
                case 'arduino_map':
                    const mapValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';
                    const fromLow = generateValueCode(block.getInputTargetBlock('FROM_LOW')) || '0';
                    const fromHigh = generateValueCode(block.getInputTargetBlock('FROM_HIGH')) || '1023';
                    const toLow = generateValueCode(block.getInputTargetBlock('TO_LOW')) || '0';
                    const toHigh = generateValueCode(block.getInputTargetBlock('TO_HIGH')) || '255';
                    return `map(${mapValue}, ${fromLow}, ${fromHigh}, ${toLow}, ${toHigh})`;

                case 'arduino_constrain':
                    const constrainValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';
                    const minValue = generateValueCode(block.getInputTargetBlock('MIN')) || '0';
                    const maxValue = generateValueCode(block.getInputTargetBlock('MAX')) || '255';
                    return `constrain(${constrainValue}, ${minValue}, ${maxValue})`;

                case 'arduino_min':
                    const minA = generateValueCode(block.getInputTargetBlock('A')) || '0';
                    const minB = generateValueCode(block.getInputTargetBlock('B')) || '0';
                    return `min(${minA}, ${minB})`;

                case 'arduino_max':
                    const maxA = generateValueCode(block.getInputTargetBlock('A')) || '0';
                    const maxB = generateValueCode(block.getInputTargetBlock('B')) || '0';
                    return `max(${maxA}, ${maxB})`;

                case 'arduino_abs':
                    const absValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';
                    return `abs(${absValue})`;

                case 'arduino_pow':
                    const powBase = generateValueCode(block.getInputTargetBlock('BASE')) || '2';
                    const powExp = generateValueCode(block.getInputTargetBlock('EXPONENT')) || '2';
                    return `pow(${powBase}, ${powExp})`;

                case 'arduino_sqrt':
                    const sqrtValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '4';
                    return `sqrt(${sqrtValue})`;

                // Arduino æ™‚é–“å‡½æ•¸ç©æœ¨
                case 'arduino_millis':
                    return 'millis()';

                case 'arduino_micros':
                    return 'micros()';

                // Arduino éš¨æ©Ÿæ•¸ç©æœ¨
                case 'arduino_random':
                    const randomMin = generateValueCode(block.getInputTargetBlock('MIN')) || '0';
                    const randomMax = generateValueCode(block.getInputTargetBlock('MAX')) || '100';
                    return `random(${randomMin}, ${randomMax})`;

                case 'arduino_random_seed':
                    const seed = generateValueCode(block.getInputTargetBlock('SEED')) || 'analogRead(0)';
                    return `${indent}randomSeed(${seed});`;

                // æ–‡å­—è™•ç†ç©æœ¨
                case 'text_string':
                    const stringValue = block.getFieldValue('TEXT') || '';
                    return `"${stringValue}"`;

                case 'text_join':
                    const textA = generateValueCode(block.getInputTargetBlock('A')) || '""';
                    const textB = generateValueCode(block.getInputTargetBlock('B')) || '""';
                    return `(String(${textA}) + String(${textB}))`;

                case 'text_length':
                    const lengthValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '""';
                    return `String(${lengthValue}).length()`;

                case 'text_isEmpty':
                    const emptyValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '""';
                    return `(String(${emptyValue}).length() == 0)`;

                case 'text_indexOf':
                    const searchValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '""';
                    const findValue = generateValueCode(block.getInputTargetBlock('FIND')) || '""';
                    return `String(${searchValue}).indexOf(String(${findValue}))`;

                case 'text_charAt':
                    const charValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '""';
                    const charAt = generateValueCode(block.getInputTargetBlock('AT')) || '0';
                    return `String(${charValue}).charAt(${charAt})`;

                case 'text_substring':
                    const subString = generateValueCode(block.getInputTargetBlock('STRING')) || '""';
                    const subFrom = generateValueCode(block.getInputTargetBlock('FROM')) || '0';
                    const subTo = generateValueCode(block.getInputTargetBlock('TO')) || '1';
                    return `String(${subString}).substring(${subFrom}, ${subTo})`;

                case 'text_changeCase':
                    const caseText = generateValueCode(block.getInputTargetBlock('TEXT')) || '""';
                    const caseMode = block.getFieldValue('CASE') || 'UPPERCASE';
                    const caseMethod = caseMode === 'UPPERCASE' ? 'toUpperCase' : 'toLowerCase';
                    return `String(${caseText}).${caseMethod}()`;

                case 'text_trim':
                    const trimText = generateValueCode(block.getInputTargetBlock('TEXT')) || '""';
                    return `String(${trimText}).trim()`;

                case 'text_replace':
                    const replaceText = generateValueCode(block.getInputTargetBlock('TEXT')) || '""';
                    const replaceFrom = generateValueCode(block.getInputTargetBlock('FROM')) || '""';
                    const replaceTo = generateValueCode(block.getInputTargetBlock('TO')) || '""';
                    return `String(${replaceText}).replace(String(${replaceFrom}), String(${replaceTo}))`;

                case 'text_number_conversion':
                    const convertValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';
                    const convertType = block.getFieldValue('TYPE') || 'STRING';
                    if (convertType === 'STRING') {
                        return `String(${convertValue})`;
                    } else {
                        return `String(${convertValue}).toInt()`;
                    }

                // æ§åˆ¶æµç¨‹ç©æœ¨
                case 'controls_if':
                    return generateControlsIf(block, indent);

                case 'controls_repeat_ext':
                    return generateControlsRepeat(block, indent);

                case 'controls_whileUntil':
                    return generateControlsWhile(block, indent);

                case 'controls_for':
                    return generateControlsFor(block, indent);

                // é‚è¼¯ç©æœ¨
                case 'logic_compare':
                    return generateLogicCompare(block);

                case 'logic_operation':
                    return generateLogicOperation(block);

                case 'logic_negate':
                    return generateLogicNegate(block);

                case 'logic_boolean':
                    return generateLogicBoolean(block);

                // æ•¸å­¸å’ŒåŸºæœ¬ç©æœ¨
                case 'math_number':
                    return validateNumber(block.getFieldValue('NUM'), '0');

                case 'math_arithmetic':
                    return generateMathArithmetic(block);

                case 'text':
                    const textValue = block.getFieldValue('TEXT') || '';
                    // æª¢æŸ¥æ˜¯å¦ç‚º Arduino å¸¸æ•¸ï¼ˆå¦‚ A0-A5, HIGH, LOWï¼‰
                    if (/^A[0-5]$/.test(textValue) || /^(HIGH|LOW|INPUT|OUTPUT|INPUT_PULLUP)$/.test(textValue)) {
                        return textValue;
                    }
                    return `"${textValue}"`;

                case 'number':
                    return validateNumber(block.getFieldValue('NUM'), '0');

                // è®Šæ•¸ç©æœ¨
                case 'variables_get':
                    return validateVariableName(block.getFieldValue('VAR'), 'variable');

                case 'variables_set':
                    return generateVariablesSet(block, indent);

                case 'variables_declare':
                    return generateVariablesDeclare(block, indent);

                case 'variables_define':
                    return generateVariablesDefine(block, indent);

                default:
                    console.warn(`Unknown block type: ${blockType}`);
                    return `${indent}// TODO: ${blockType} ç©æœ¨`;
            }
        }

        // æ§åˆ¶æµç¨‹ç©æœ¨ç”Ÿæˆå‡½æ•¸
        function generateControlsIf(block, indent) {
            const condition = generateValueCode(block.getInputTargetBlock('IF0')) || 'true';
            const doCode = generateBlockCode(block.getInputTargetBlock('DO0'), indent + '  ');
            const elseCode = generateBlockCode(block.getInputTargetBlock('ELSE'), indent + '  ');

            // ç¢ºä¿ doCode æ¯ä¸€è¡Œéƒ½æœ‰æ­£ç¢ºçš„ç¸®æ’
            const formattedDoCode = doCode.split('\n')
                .map(line => line.trim() ? (line.startsWith(indent + '  ') ? line : indent + '  ' + line.trim()) : line)
                .join('\n');

            let code = `${indent}if (${condition}) {\n${formattedDoCode}\n${indent}}`;

            if (elseCode && elseCode.trim() !== '// è«‹æ‹–æ›³ç©æœ¨åˆ°é€™è£¡') {
                const formattedElseCode = elseCode.split('\n')
                    .map(line => line.trim() ? (line.startsWith(indent + '  ') ? line : indent + '  ' + line.trim()) : line)
                    .join('\n');
                code += ` else {\n${formattedElseCode}\n${indent}}`;
            }
            return code;
        }

        function generateControlsRepeat(block, indent) {
            const times = validateNumber(generateValueCode(block.getInputTargetBlock('TIMES')), '10', 0);
            const doCode = generateBlockCode(block.getInputTargetBlock('DO'), indent + '  ');

            const formattedDoCode = doCode.split('\n')
                .map(line => line.trim() ? (line.startsWith(indent + '  ') ? line : indent + '  ' + line.trim()) : line)
                .join('\n');

            return `${indent}for (int i = 0; i < ${times}; i++) {\n${formattedDoCode}\n${indent}}`;
        }

        function generateControlsWhile(block, indent) {
            const mode = block.getFieldValue('MODE');
            const condition = generateValueCode(block.getInputTargetBlock('BOOL')) || 'true';
            const doCode = generateBlockCode(block.getInputTargetBlock('DO'), indent + '  ');

            const formattedDoCode = doCode.split('\n')
                .map(line => line.trim() ? (line.startsWith(indent + '  ') ? line : indent + '  ' + line.trim()) : line)
                .join('\n');

            const whileCondition = mode === 'WHILE' ? condition : `!(${condition})`;
            return `${indent}while (${whileCondition}) {\n${formattedDoCode}\n${indent}}`;
        }

        function generateControlsFor(block, indent) {
            const variable = validateVariableName(block.getFieldValue('VAR'), 'i');
            const from = validateNumber(generateValueCode(block.getInputTargetBlock('FROM')), '1');
            const to = validateNumber(generateValueCode(block.getInputTargetBlock('TO')), '10');
            const by = validateNumber(generateValueCode(block.getInputTargetBlock('BY')), '1');
            const doCode = generateBlockCode(block.getInputTargetBlock('DO'), indent + '  ');

            const formattedDoCode = doCode.split('\n')
                .map(line => line.trim() ? (line.startsWith(indent + '  ') ? line : indent + '  ' + line.trim()) : line)
                .join('\n');

            return `${indent}for (int ${variable} = ${from}; ${variable} <= ${to}; ${variable} += ${by}) {\n${formattedDoCode}\n${indent}}`;
        }

        // é‚è¼¯ç©æœ¨ç”Ÿæˆå‡½æ•¸
        function generateLogicCompare(block) {
            const operator = block.getFieldValue('OP');
            const a = generateValueCode(block.getInputTargetBlock('A')) || '0';
            const b = generateValueCode(block.getInputTargetBlock('B')) || '0';

            const operators = {
                'EQ': '==', 'NEQ': '!=', 'LT': '<', 'LTE': '<=', 'GT': '>', 'GTE': '>='
            };

            return `${a} ${operators[operator] || '=='} ${b}`;
        }

        function generateLogicOperation(block) {
            const operator = block.getFieldValue('OP');
            const a = generateValueCode(block.getInputTargetBlock('A')) || 'false';
            const b = generateValueCode(block.getInputTargetBlock('B')) || 'false';

            return `${a} ${operator === 'AND' ? '&&' : '||'} ${b}`;
        }

        function generateLogicNegate(block) {
            const bool = generateValueCode(block.getInputTargetBlock('BOOL')) || 'false';
            return `!(${bool})`;
        }

        function generateLogicBoolean(block) {
            return block.getFieldValue('BOOL') === 'TRUE' ? 'true' : 'false';
        }

        // æ•¸å­¸ç©æœ¨ç”Ÿæˆå‡½æ•¸
        function generateMathArithmetic(block) {
            const operator = block.getFieldValue('OP');
            const a = generateValueCode(block.getInputTargetBlock('A')) || '0';
            const b = generateValueCode(block.getInputTargetBlock('B')) || '0';

            const operators = {
                'ADD': '+', 'MINUS': '-', 'MULTIPLY': '*', 'DIVIDE': '/', 'POWER': 'pow'
            };

            if (operator === 'POWER') {
                return `pow(${a}, ${b})`;
            }

            return `${a} ${operators[operator] || '+'} ${b}`;
        }

        // è®Šæ•¸ç©æœ¨ç”Ÿæˆå‡½æ•¸
        function generateVariablesSet(block, indent) {
            const variable = validateVariableName(block.getFieldValue('VAR'), 'variable');
            const value = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';

            return `${indent}${variable} = ${value};`;
        }

        function generateVariablesDeclare(block, indent) {
            const type = block.getFieldValue('TYPE') || 'int';
            const variable = validateVariableName(block.getFieldValue('VAR'), 'myVar');

            return `${indent}${type} ${variable};`;
        }

        function generateVariablesDefine(block, indent) {
            const type = block.getFieldValue('TYPE') || 'int';
            const variable = validateVariableName(block.getFieldValue('VAR'), 'myVar');
            const value = generateValueCode(block.getInputTargetBlock('VALUE')) || getDefaultValueForType(type);

            return `${type} ${variable} = ${value};`;
        }

        // æ ¹æ“šé¡å‹å–å¾—é è¨­å€¼
        function getDefaultValueForType(type) {
            switch (type) {
                case 'int':
                    return '0';
                case 'float':
                    return '0.0';
                case 'boolean':
                    return 'false';
                case 'char':
                    return "'a'";
                case 'String':
                    return '""';
                default:
                    return '0';
            }
        }

        // è¼”åŠ©å‡½æ•¸ï¼šç”Ÿæˆå€¼è¡¨é”å¼çš„ç¨‹å¼ç¢¼
        function generateValueCode(block) {
            if (!block) {
                return '';
            }
            return generateSingleBlockCode(block, '').trim();
        }

        // é©—è­‰å’Œæ¸…ç†æ•¸å€¼
        function validateNumber(value, defaultValue = '0', min = null, max = null) {
            if (value === null || value === undefined || value === '') {
                return defaultValue;
            }

            const num = parseFloat(value);
            if (isNaN(num)) {
                return defaultValue;
            }

            if (min !== null && num < min) {
                return min.toString();
            }

            if (max !== null && num > max) {
                return max.toString();
            }

            // å°æ–¼æ•´æ•¸ï¼Œç§»é™¤å°æ•¸é»
            if (Number.isInteger(num)) {
                return Math.floor(num).toString();
            }

            return num.toString();
        }

        // é©—è­‰å’Œæ¸…ç†è®Šæ•¸åç¨±
        function validateVariableName(name, defaultName = 'variable') {
            if (!name || typeof name !== 'string') {
                return defaultName;
            }

            // å˜—è©¦å¾ workspace ä¸­ç²å–è®Šæ•¸çš„å¯¦éš›åç¨±
            if (workspace) {
                const variable = workspace.getVariableById(name);
                if (variable && variable.name) {
                    name = variable.name;
                }
            }

            // ç§»é™¤ç„¡æ•ˆå­—ç¬¦ï¼Œåªä¿ç•™å­—æ¯ã€æ•¸å­—å’Œåº•ç·š
            let cleanName = name.replace(/[^a-zA-Z0-9_]/g, '');

            // ç¢ºä¿ä»¥å­—æ¯æˆ–åº•ç·šé–‹å§‹
            if (cleanName && /^[0-9]/.test(cleanName)) {
                cleanName = '_' + cleanName;
            }

            // å¦‚æœæ¸…ç†å¾Œç‚ºç©ºï¼Œä½¿ç”¨é è¨­åç¨±
            if (!cleanName) {
                return defaultName;
            }

            // é¿å… Arduino é—œéµå­—
            const arduinoKeywords = ['setup', 'loop', 'void', 'int', 'float', 'char', 'byte', 'boolean', 'true', 'false', 'HIGH', 'LOW'];
            if (arduinoKeywords.includes(cleanName.toLowerCase())) {
                return '_' + cleanName;
            }

            return cleanName;
        }

        // æ‰‹å‹•åŒæ­¥ï¼šç©æœ¨åˆ°ç¨‹å¼ç¢¼
        function manualSyncToCode() {
            try {
                showLoading();
                console.log('Manual sync: blocks to code');

                // æª¢æŸ¥å·¥ä½œå€ä¸­çš„ç©æœ¨
                const allBlocks = workspace.getAllBlocks();
                console.log('Total blocks in workspace:', allBlocks.length);
                console.log('Block types:', allBlocks.map(b => b.type));

                // å¦‚æœå·¥ä½œå€æ˜¯ç©ºçš„ï¼Œè‡ªå‹•å‰µå»ºåŸºæœ¬çš„ setup å’Œ loop ç©æœ¨
                if (allBlocks.length === 0) {
                    console.log('Workspace is empty, creating default blocks');
                    createTestBlocks();
                }

                const code = generateArduinoCode();
                console.log('Generated code (full):');
                console.log(code);
                console.log('Code length:', code.length);

                if (!code || code.trim().length === 0) {
                    hideLoading();
                    showError('ç„¡æ³•ç”Ÿæˆç¨‹å¼ç¢¼ï¼šå·¥ä½œå€ç‚ºç©ºæˆ–ç©æœ¨ç„¡æ•ˆ');
                    return;
                }

                // ç™¼é€åŒæ­¥è¨Šæ¯åˆ° VSCode
                vscode.postMessage({
                    command: 'manualSyncToCode',
                    data: { code: code }
                });

                hideLoading();
                console.log('Manual sync to code completed');
            } catch (error) {
                hideLoading();
                showError('åŒæ­¥åˆ°ç¨‹å¼ç¢¼å¤±æ•—: ' + error.message);
                console.error('Manual sync to code error:', error);
            }
        }

        // æ‰‹å‹•åŒæ­¥ï¼šç¨‹å¼ç¢¼åˆ°ç©æœ¨
        function manualSyncToBlocks() {
            try {
                showLoading();
                console.log('Manual sync: code to blocks');

                // è«‹æ±‚ VSCode æä¾›ç•¶å‰ç¨‹å¼ç¢¼
                vscode.postMessage({
                    command: 'manualSyncToBlocks'
                });

                console.log('Manual sync to blocks request sent');
            } catch (error) {
                hideLoading();
                showError('åŒæ­¥åˆ°ç©æœ¨å¤±æ•—: ' + error.message);
                console.error('Manual sync to blocks error:', error);
            }
        }

        // é¡¯ç¤ºè¼‰å…¥ç‹€æ…‹
        function showLoading() {
            document.getElementById('loading').style.display = 'flex';
        }

        // éš±è—è¼‰å…¥ç‹€æ…‹
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // æ›´æ–°ç©æœ¨æ•¸é‡
        function updateBlockCount() {
            const count = workspace.getAllBlocks().length;
            document.getElementById('blockCount').textContent = count;
        }


        // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }

        // éš±è—éŒ¯èª¤è¨Šæ¯
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // å·¥å…·åˆ—æŒ‰éˆ•äº‹ä»¶
        document.getElementById('saveBtn').addEventListener('click', () => {
            let xmlText;
            try {
                if (typeof Blockly.utils !== 'undefined' && Blockly.utils.xml) {
                    // æ–°ç‰ˆ Blockly API
                    const xmlDom = Blockly.serialization.workspaces.save(workspace);
                    xmlText = Blockly.utils.xml.domToText(xmlDom);
                } else if (typeof Blockly.Xml !== 'undefined' && typeof Blockly.Xml.workspaceToDom === 'function') {
                    // èˆŠç‰ˆ Blockly API
                    const xmlDom = Blockly.Xml.workspaceToDom(workspace);
                    if (typeof Blockly.Xml.domToText === 'function') {
                        xmlText = Blockly.Xml.domToText(xmlDom);
                    } else {
                        xmlText = new XMLSerializer().serializeToString(xmlDom);
                    }
                } else {
                    xmlText = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
                }
            } catch (error) {
                console.error('Error saving template:', error);
                xmlText = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
            }

            vscode.postMessage({
                command: 'saveTemplate',
                data: { xml: xmlText }
            });
        });

        document.getElementById('loadBtn').addEventListener('click', () => {
            vscode.postMessage({ command: 'loadTemplate' });
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('ç¢ºå®šè¦æ¸…ç©ºå·¥ä½œå€å—ï¼Ÿ')) {
                workspace.clear();
            }
        });


        document.getElementById('syncToCodeBtn').addEventListener('click', () => {
            console.log('Sync to code button clicked');
            manualSyncToCode();
        });

        document.getElementById('syncToBlocksBtn').addEventListener('click', () => {
            console.log('Sync to blocks button clicked');
            manualSyncToBlocks();
        });


        // VSCode è¨Šæ¯è™•ç†
        window.addEventListener('message', event => {
            const message = event.data;
            console.log('Received message from VSCode:', message.command);

            switch (message.command) {
                case 'loadWorkspace':
                    if (message.data && message.data.xml) {
                        console.log('Loading workspace from XML:', message.data.xml.substring(0, 200));
                        console.log('Full XML length:', message.data.xml.length);

                        // æª¢æŸ¥XMLä¸­æ˜¯å¦åŒ…å«loopå…§å®¹
                        if (message.data.xml.includes('LOOP_CODE')) {
                            console.log('âœ… XML contains LOOP_CODE section');
                            if (message.data.xml.includes('variables_define')) {
                                console.log('âœ… XML contains variables_define blocks');
                            } else {
                                console.log('âŒ XML missing variables_define blocks');
                            }
                            if (message.data.xml.includes('arduino_serial_print')) {
                                console.log('âœ… XML contains arduino_serial_print blocks');
                            } else {
                                console.log('âŒ XML missing arduino_serial_print blocks');
                            }
                        } else {
                            console.log('âŒ XML missing LOOP_CODE section');
                        }

                        try {
                            // æš«æ™‚ç¦ç”¨å·¥ä½œå€è®Šæ›´äº‹ä»¶ä»¥é˜²æ­¢å¾ªç’°
                            workspace.removeChangeListener(onWorkspaceChange);

                            // æ¸…ç©ºç¾æœ‰å·¥ä½œå€
                            workspace.clear();

                            // é è™•ç†è®Šæ•¸ï¼šåœ¨è¼‰å…¥ XML ä¹‹å‰å‰µå»ºæ‰€æœ‰è®Šæ•¸
                            const varMatches = message.data.xml.match(/<field name="VAR">([^<]+)<\/field>/g);
                            if (varMatches) {
                                const uniqueVars = new Set();
                                varMatches.forEach(match => {
                                    const varName = match.match(/<field name="VAR">([^<]+)<\/field>/)[1];
                                    uniqueVars.add(varName);
                                });

                                console.log('ğŸ“‹ Creating variables before XML load:', Array.from(uniqueVars));
                                uniqueVars.forEach(varName => {
                                    try {
                                        // å‰µå»ºè®Šæ•¸ï¼Œè®Šæ•¸åç¨±å’Œ ID éƒ½ä½¿ç”¨åŒä¸€å€‹åç¨±
                                        workspace.createVariable(varName, null, varName);
                                    } catch (error) {
                                        console.log('è®Šæ•¸å‰µå»ºå¤±æ•—:', varName, error);
                                    }
                                });
                            }

                            // è¼‰å…¥æ–°çš„å·¥ä½œå€ - ä½¿ç”¨ä¸åŒçš„ API æ–¹æ³•
                            let xml;
                            let loadSuccess = false;

                            // å˜—è©¦æ–°ç‰ˆ Blockly APIï¼ˆä½†ä½¿ç”¨ XML è€Œä¸æ˜¯ serializationï¼‰
                            if (typeof Blockly.utils !== 'undefined' && Blockly.utils.xml) {
                                try {
                                    console.log('Trying new Blockly API (utils.xml)');
                                    xml = Blockly.utils.xml.textToDom(message.data.xml);
                                    // ä½¿ç”¨ Xml.domToWorkspace è€Œä¸æ˜¯ serialization.workspaces.load
                                    if (typeof Blockly.Xml !== 'undefined' && typeof Blockly.Xml.domToWorkspace === 'function') {
                                        Blockly.Xml.domToWorkspace(xml, workspace);
                                        loadSuccess = true;
                                        console.log('New API with domToWorkspace load successful');
                                    }
                                } catch (error) {
                                    console.log('New API failed:', error);
                                }
                            }

                            // å˜—è©¦èˆŠç‰ˆ Blockly API
                            if (!loadSuccess && typeof Blockly.Xml !== 'undefined') {
                                if (typeof Blockly.Xml.textToDom === 'function') {
                                    try {
                                        console.log('Trying old Blockly API (Xml.textToDom)');
                                        xml = Blockly.Xml.textToDom(message.data.xml);
                                        Blockly.Xml.domToWorkspace(xml, workspace);
                                        loadSuccess = true;
                                        console.log('Old API load successful');
                                    } catch (error) {
                                        console.log('Old API with textToDom failed:', error);
                                    }
                                } else if (typeof Blockly.Xml.domToWorkspace === 'function') {
                                    try {
                                        console.log('Trying DOMParser + domToWorkspace');
                                        const parser = new DOMParser();
                                        xml = parser.parseFromString(message.data.xml, 'text/xml');
                                        Blockly.Xml.domToWorkspace(xml, workspace);
                                        loadSuccess = true;
                                        console.log('DOMParser + domToWorkspace successful');
                                    } catch (error) {
                                        console.log('DOMParser + domToWorkspace failed:', error);
                                    }
                                }
                            }

                            // æœ€å¾Œçš„å‚™ç”¨æ–¹æ¡ˆ - å˜—è©¦æ›´ç°¡å–®çš„æ–¹æ³•
                            if (!loadSuccess) {
                                console.log('All standard methods failed, trying simplified approach');
                                try {
                                    // å˜—è©¦æœ€ç›´æ¥çš„æ–¹æ³•
                                    const parser = new DOMParser();
                                    const xmlDoc = parser.parseFromString(message.data.xml, 'text/xml');
                                    const xmlElement = xmlDoc.documentElement;

                                    if (typeof Blockly.Xml.domToWorkspace === 'function') {
                                        Blockly.Xml.domToWorkspace(xmlElement, workspace);
                                        loadSuccess = true;
                                        console.log('Simplified domToWorkspace successful');
                                    }
                                } catch (error) {
                                    console.error('Simplified approach failed:', error);
                                    console.log('XML that failed to load:', message.data.xml);
                                }
                            }

                            // é‡æ–°å•Ÿç”¨è®Šæ›´äº‹ä»¶
                            setTimeout(() => {
                                workspace.addChangeListener(onWorkspaceChange);

                                // æª¢æŸ¥è¼‰å…¥çµæœ
                                const allBlocks = workspace.getAllBlocks();
                                console.log(`ğŸ“Š Workspace loaded with ${allBlocks.length} total blocks`);

                                const setupBlocks = allBlocks.filter(block => block.type === 'arduino_setup');
                                const loopBlocks = allBlocks.filter(block => block.type === 'arduino_loop');
                                console.log(`- Setup blocks: ${setupBlocks.length}`);
                                console.log(`- Loop blocks: ${loopBlocks.length}`);

                                // æª¢æŸ¥loopç©æœ¨çš„å…§å®¹
                                if (loopBlocks.length > 0) {
                                    const loopBlock = loopBlocks[0];
                                    const loopConnection = loopBlock.getInput('LOOP_CODE');
                                    if (loopConnection && loopConnection.connection && loopConnection.connection.targetBlock()) {
                                        const connectedBlocks = [];
                                        let currentBlock = loopConnection.connection.targetBlock();
                                        while (currentBlock) {
                                            connectedBlocks.push(currentBlock.type);
                                            currentBlock = currentBlock.getNextBlock();
                                        }
                                        console.log(`ğŸ”— Loop contains blocks: ${connectedBlocks.join(' â†’ ')}`);
                                    } else {
                                        console.log('âŒ Loop block has no connected blocks');
                                    }
                                }

                                updateBlockCount();
                            }, 100);

                            console.log('Workspace loaded successfully');
                            // éš±è—è¼‰å…¥ç‹€æ…‹
                            hideLoading();
                        } catch (error) {
                            console.error('Failed to load workspace:', error);
                            showError('è¼‰å…¥å·¥ä½œå€å¤±æ•—: ' + error.message);
                            hideLoading();
                        }
                    }
                    break;
                case 'syncCode':
                    generateCode();
                    break;
            }
        });

        // æ‰‹å‹•å¾ XML å‰µå»ºç©æœ¨ï¼ˆå‚™ç”¨æ–¹æ¡ˆï¼‰
        function createBlocksFromXml(xmlDoc) {
            console.log('Creating blocks manually from XML');

            const blocks = xmlDoc.getElementsByTagName('block');
            console.log('Found', blocks.length, 'blocks in XML');

            for (let i = 0; i < blocks.length; i++) {
                const blockElement = blocks[i];
                const blockType = blockElement.getAttribute('type');
                console.log('Processing block type:', blockType);

                if (blockType === 'arduino_setup' || blockType === 'arduino_loop') {
                    console.log('Creating', blockType, 'block');

                    try {
                        // æª¢æŸ¥ç©æœ¨é¡å‹æ˜¯å¦å­˜åœ¨
                        if (!Blockly.Blocks[blockType]) {
                            console.error('Block type not found:', blockType);
                            console.log('Available block types:', Object.keys(Blockly.Blocks));
                            continue;
                        }

                        // å‰µå»ºç©æœ¨
                        const block = workspace.newBlock(blockType);
                        console.log('Block created:', block);

                        // è¨­ç½®ä½ç½®
                        const x = parseInt(blockElement.getAttribute('x')) || (blockType === 'arduino_setup' ? 50 : 50);
                        const y = parseInt(blockElement.getAttribute('y')) || (blockType === 'arduino_setup' ? 50 : 250);
                        console.log('Moving block to position:', x, y);
                        block.moveBy(x, y);

                        // åˆå§‹åŒ–ä¸¦æ¸²æŸ“ç©æœ¨
                        block.initSvg();
                        block.render();
                        console.log('Block rendered successfully');
                    } catch (error) {
                        console.error('Error creating block:', blockType, error);
                    }
                }
            }

            console.log('Manual block creation completed');
            console.log('Total blocks in workspace:', workspace.getAllBlocks().length);
        }

        // æ‰‹å‹•å‰µå»ºå…©å€‹åŸºæœ¬ç©æœ¨ä¾†æ¸¬è©¦é¡¯ç¤º
        function createTestBlocks() {
            console.log('Creating test blocks manually');

            try {
                // å‰µå»º setup ç©æœ¨
                const setupBlock = workspace.newBlock('arduino_setup');
                setupBlock.moveBy(50, 50);
                setupBlock.initSvg();
                setupBlock.render();
                console.log('Setup block created');

                // å‰µå»º loop ç©æœ¨
                const loopBlock = workspace.newBlock('arduino_loop');
                loopBlock.moveBy(50, 250);
                loopBlock.initSvg();
                loopBlock.render();
                console.log('Loop block created');

                console.log('Test blocks created successfully');
                console.log('Total blocks in workspace:', workspace.getAllBlocks().length);
            } catch (error) {
                console.error('Error creating test blocks:', error);
                console.log('Available block types:', Object.keys(Blockly.Blocks));
            }
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', initBlockly);
    </script>
</body>
</html>