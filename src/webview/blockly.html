<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TextBlockly - Arduino Visual Programming</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--vscode-editor-background);
            color: var(--vscode-editor-foreground);
        }

        .container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        .toolbar {
            background-color: var(--vscode-titleBar-activeBackground);
            color: var(--vscode-titleBar-activeForeground);
            padding: 8px 16px;
            border-bottom: 1px solid var(--vscode-panel-border);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toolbar button {
            background-color: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s;
        }

        .toolbar button:hover {
            background-color: var(--vscode-button-hoverBackground);
        }

        .toolbar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .blockly-area {
            flex: 1;
            position: relative;
        }

        #blocklyDiv {
            height: 100%;
            width: 100%;
        }

        .status-bar {
            background-color: var(--vscode-statusBar-background);
            color: var(--vscode-statusBar-foreground);
            padding: 4px 16px;
            font-size: 11px;
            border-top: 1px solid var(--vscode-panel-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .loading {
            display: none;
            align-items: center;
            gap: 8px;
        }

        .spinner {
            width: 12px;
            height: 12px;
            border: 2px solid transparent;
            border-top: 2px solid var(--vscode-progressBar-background);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background-color: var(--vscode-inputValidation-errorBackground);
            color: var(--vscode-inputValidation-errorForeground);
            border: 1px solid var(--vscode-inputValidation-errorBorder);
            padding: 8px 12px;
            margin: 8px;
            border-radius: 4px;
            display: none;
        }

        /* 修正 Blockly 工具箱標題顏色 */
        .blocklyTreeLabel,
        .goog-tree-item-label {
            color: var(--vscode-sideBarTitle-foreground, var(--vscode-foreground)) !important;
            font-weight: 600;
            text-shadow: 0 0 1px rgba(0, 0, 0, 0.5);
        }

        /* 修正工具箱背景和邊框 */
        .blocklyToolboxDiv {
            background-color: var(--vscode-sideBar-background) !important;
            border-right: 1px solid var(--vscode-sideBar-border) !important;
        }

        /* 為工具箱項目添加更好的對比度 */
        .blocklyTreeRow {
            background-color: rgba(255, 255, 255, 0.05) !important;
            margin: 2px 4px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* 修正飛出選單背景 */
        .blocklyFlyout {
            background-color: var(--vscode-sideBar-background) !important;
        }

        /* 修正分類選中狀態 */
        .blocklyTreeRow.blocklyTreeRowSelected {
            background-color: var(--vscode-list-activeSelectionBackground) !important;
        }

        .blocklyTreeRow.blocklyTreeRowSelected .blocklyTreeLabel {
            color: var(--vscode-list-activeSelectionForeground) !important;
        }

        /* 修正分類懸停狀態 */
        .blocklyTreeRow:hover {
            background-color: var(--vscode-list-hoverBackground) !important;
        }

        .blocklyTreeRow:hover .blocklyTreeLabel {
            color: var(--vscode-list-hoverForeground) !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 工具列 -->
        <div class="toolbar">
            <button id="saveBtn" title="儲存為模板">💾 儲存</button>
            <button id="loadBtn" title="載入模板">📂 載入</button>
            <button id="clearBtn" title="清空工作區">🗑️ 清空</button>
            <div style="border-left: 1px solid var(--vscode-panel-border); margin: 0 8px; height: 20px;"></div>
            <button id="syncToCodeBtn" title="將積木同步到程式碼">🔄 同步到程式碼</button>
            <button id="syncToBlocksBtn" title="將程式碼同步到積木">🔃 同步到積木</button>
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <span>同步中...</span>
            </div>
        </div>

        <!-- 錯誤訊息 -->
        <div class="error-message" id="errorMessage"></div>

        <!-- 主要內容區域 -->
        <div class="main-content">
            <!-- Blockly 工作區 -->
            <div class="blockly-area">
                <div id="blocklyDiv"></div>
            </div>
        </div>

        <!-- 狀態列 -->
        <div class="status-bar">
            <div class="status-item">
                <span>積木數量: </span>
                <span id="blockCount">0</span>
            </div>
            <div class="status-item">
                <span id="syncStatus">就緒 - 程式碼即時同步到右側編輯器</span>
            </div>
        </div>
    </div>

    <!-- Blockly 核心庫 -->
    <script src="{{BLOCKLY_PATH}}/blockly_compressed.js"></script>
    <script src="{{BLOCKLY_PATH}}/blocks_compressed.js"></script>
    <script src="{{BLOCKLY_PATH}}/msg/zh-hant.js"></script>

    <script>
        // 全域變數
        let workspace;
        let vscode;
        let codeGenerationTimer;

        // VSCode API
        if (typeof acquireVsCodeApi !== 'undefined') {
            vscode = acquireVsCodeApi();
        } else {
            // 開發環境模擬
            vscode = {
                postMessage: (message) => console.log('VSCode Message:', message),
                getState: () => null,
                setState: (state) => console.log('VSCode State:', state)
            };
        }

        // Arduino 積木定義
        const ARDUINO_BLOCKS = {{ARDUINO_BLOCKS}};

        // 工具箱配置
        const TOOLBOX = {{TOOLBOX}};

        // 變數計數器用於生成預設名稱
        let variableCounter = 1;

        // 全局覆蓋 prompt 函數以顯示自定義對話框
        window.prompt = function(message, defaultValue) {
            console.log('🔥 PROMPT INTERCEPTED:', {
                message: message,
                defaultValue: defaultValue,
                timestamp: new Date().toISOString()
            });

            // 檢查是否為變數創建相關的提示
            if (message && (message.includes('variable') || message.includes('變數') || message.includes('name') ||
                           message.includes('Create') || message.includes('New'))) {

                // 生成預設變數名稱
                const suggestedName = defaultValue || `variable${variableCounter}`;
                variableCounter++;

                console.log('🎯 Variable creation detected:', {
                    suggestedName: suggestedName,
                    counter: variableCounter,
                    workspaceAvailable: !!workspace
                });

                // 顯示異步對話框，如果用戶更改名稱，則更新變數
                setTimeout(() => {
                    console.log('⏰ Starting async dialog for variable:', suggestedName);

                    showVariableNameDialogAsync(message, suggestedName, (userResult) => {
                        console.log('📨 Async dialog callback received:', {
                            userResult: userResult,
                            originalName: suggestedName,
                            changed: userResult !== suggestedName
                        });

                        if (userResult && userResult !== suggestedName && workspace && workspace.createVariable) {
                            console.log('🔄 User changed variable name, attempting replacement...');

                            try {
                                // 先查找預設變數
                                const allVars = workspace.getAllVariables();
                                console.log('📋 Current variables:', allVars.map(v => v.name));

                                const defaultVar = workspace.getVariable(suggestedName);
                                if (defaultVar) {
                                    console.log('🗑️ Deleting default variable:', suggestedName);
                                    workspace.deleteVariableById(defaultVar.getId());
                                } else {
                                    console.log('⚠️ Default variable not found:', suggestedName);
                                }

                                // 創建用戶指定的變數
                                console.log('➕ Creating user variable:', userResult);
                                const newVar = workspace.createVariable(userResult, null, userResult);
                                console.log('✅ Successfully created user variable:', {
                                    name: newVar.name,
                                    id: newVar.getId()
                                });

                                // 刷新工具箱以更新變數列表
                                if (workspace.refreshToolboxSelection) {
                                    workspace.refreshToolboxSelection();
                                }

                            } catch (error) {
                                console.error('❌ Error updating variable name:', error);
                            }
                        } else if (!userResult) {
                            console.log('❌ User cancelled variable creation');
                        } else if (userResult === suggestedName) {
                            console.log('📝 User kept the suggested name:', suggestedName);
                        } else if (!workspace) {
                            console.error('❌ Workspace not available for variable update');
                        }
                    });
                }, 150); // 增加延遲以確保 Blockly 完全初始化

                // 立即返回預設名稱給 Blockly
                console.log('📤 Returning default name to Blockly:', suggestedName);
                return suggestedName;
            }

            // 對於其他提示，返回默認值或空字符串
            console.log('❓ Non-variable prompt, returning default:', defaultValue || '');
            return defaultValue || '';
        };

        // 初始化 Blockly
        function initBlockly() {
            try {
                // 註冊 Arduino 積木
                registerArduinoBlocks();

                // 創建工作區
                workspace = Blockly.inject('blocklyDiv', {
                    toolbox: TOOLBOX,
                    grid: {
                        spacing: 20,
                        length: 3,
                        colour: '#ccc',
                        snap: true
                    },
                    zoom: {
                        controls: true,
                        wheel: true,
                        startScale: 1.0,
                        maxScale: 3,
                        minScale: 0.3,
                        scaleSpeed: 1.2
                    },
                    trashcan: true,
                    theme: Blockly.Themes.Classic
                });

                // 監聽工作區變更
                workspace.addChangeListener(onWorkspaceChange);

                // 初始化變數系統 - 創建預設變數以啟用變數功能
                console.log('🔧 Initializing variable system...');
                if (workspace.createVariable) {
                    workspace.createVariable('item', null, 'item');
                    console.log('✅ Created default variable: item');
                } else {
                    console.warn('❌ workspace.createVariable not available');
                }

                // 檢查變數管理系統
                if (Blockly.Variables) {
                    console.log('✅ Blockly.Variables is available');
                    console.log('Variables methods:', Object.keys(Blockly.Variables));
                } else {
                    console.warn('❌ Blockly.Variables not available');
                }

                // 檢查工具箱中的變數類別
                console.log('📊 Checking variable category in toolbox...');
                const toolboxXml = workspace.getToolbox();
                if (toolboxXml) {
                    console.log('✅ Toolbox found');
                } else {
                    console.warn('❌ No toolbox found');
                }

                console.log('✅ Variable creation will be handled by global prompt() override');

                // 手動同步模式 - 不自動生成程式碼
                console.log('Blockly initialized in manual sync mode');

                // 通知 VSCode Blockly 已準備就緒
                vscode.postMessage({
                    command: 'blocklyReady',
                    data: { blockCount: workspace.getAllBlocks().length }
                });

                console.log('Blockly 初始化成功，已通知 VSCode');
            } catch (error) {
                showError('Blockly 初始化失敗: ' + error.message);
                console.error('Blockly 初始化錯誤:', error);
            }
        }

        // 註冊 Arduino 積木
        function registerArduinoBlocks() {
            ARDUINO_BLOCKS.forEach(block => {
                Blockly.Blocks[block.type] = {
                    init: function() {
                        this.jsonInit(block);
                    }
                };
            });

            // 註冊標準 Blockly 邏輯積木
            if (!Blockly.Blocks['logic_compare']) {
                Blockly.Blocks['logic_compare'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'logic_compare',
                            message0: '%1 %2 %3',
                            args0: [
                                { type: 'input_value', name: 'A', check: null },
                                {
                                    type: 'field_dropdown',
                                    name: 'OP',
                                    options: [
                                        ['=', 'EQ'],
                                        ['≠', 'NEQ'],
                                        ['<', 'LT'],
                                        ['≤', 'LTE'],
                                        ['>', 'GT'],
                                        ['≥', 'GTE']
                                    ]
                                },
                                { type: 'input_value', name: 'B', check: null }
                            ],
                            inputsInline: true,
                            output: 'Boolean',
                            colour: 210,
                            tooltip: '比較兩個值',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['logic_operation']) {
                Blockly.Blocks['logic_operation'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'logic_operation',
                            message0: '%1 %2 %3',
                            args0: [
                                { type: 'input_value', name: 'A', check: 'Boolean' },
                                {
                                    type: 'field_dropdown',
                                    name: 'OP',
                                    options: [
                                        ['且', 'AND'],
                                        ['或', 'OR']
                                    ]
                                },
                                { type: 'input_value', name: 'B', check: 'Boolean' }
                            ],
                            inputsInline: true,
                            output: 'Boolean',
                            colour: 210,
                            tooltip: '邏輯運算',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['logic_negate']) {
                Blockly.Blocks['logic_negate'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'logic_negate',
                            message0: '不是 %1',
                            args0: [
                                { type: 'input_value', name: 'BOOL', check: 'Boolean' }
                            ],
                            output: 'Boolean',
                            colour: 210,
                            tooltip: '邏輯否定',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['logic_boolean']) {
                Blockly.Blocks['logic_boolean'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'logic_boolean',
                            message0: '%1',
                            args0: [
                                {
                                    type: 'field_dropdown',
                                    name: 'BOOL',
                                    options: [
                                        ['真', 'TRUE'],
                                        ['假', 'FALSE']
                                    ]
                                }
                            ],
                            output: 'Boolean',
                            colour: 210,
                            tooltip: '布林值',
                            helpUrl: ''
                        });
                    }
                };
            }

            // 註冊控制流積木
            if (!Blockly.Blocks['controls_if']) {
                Blockly.Blocks['controls_if'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'controls_if',
                            message0: '如果 %1',
                            message1: '執行 %1',
                            args0: [
                                { type: 'input_value', name: 'IF0', check: 'Boolean' }
                            ],
                            args1: [
                                { type: 'input_statement', name: 'DO0' }
                            ],
                            previousStatement: null,
                            nextStatement: null,
                            colour: 210,
                            tooltip: '如果條件為真，執行語句',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['controls_repeat_ext']) {
                Blockly.Blocks['controls_repeat_ext'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'controls_repeat_ext',
                            message0: '重複 %1 次',
                            message1: '執行 %1',
                            args0: [
                                { type: 'input_value', name: 'TIMES', check: 'Number' }
                            ],
                            args1: [
                                { type: 'input_statement', name: 'DO' }
                            ],
                            previousStatement: null,
                            nextStatement: null,
                            colour: 120,
                            tooltip: '重複執行指定次數',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['controls_whileUntil']) {
                Blockly.Blocks['controls_whileUntil'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'controls_whileUntil',
                            message0: '%1 %2',
                            message1: '執行 %1',
                            args0: [
                                {
                                    type: 'field_dropdown',
                                    name: 'MODE',
                                    options: [
                                        ['當', 'WHILE'],
                                        ['直到', 'UNTIL']
                                    ]
                                },
                                { type: 'input_value', name: 'BOOL', check: 'Boolean' }
                            ],
                            args1: [
                                { type: 'input_statement', name: 'DO' }
                            ],
                            previousStatement: null,
                            nextStatement: null,
                            colour: 120,
                            tooltip: '條件迴圈',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['controls_for']) {
                Blockly.Blocks['controls_for'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'controls_for',
                            message0: '計數 %1 從 %2 到 %3 每次增加 %4',
                            message1: '執行 %1',
                            args0: [
                                { type: 'field_variable', name: 'VAR', variable: 'i' },
                                { type: 'input_value', name: 'FROM', check: 'Number' },
                                { type: 'input_value', name: 'TO', check: 'Number' },
                                { type: 'input_value', name: 'BY', check: 'Number' }
                            ],
                            args1: [
                                { type: 'input_statement', name: 'DO' }
                            ],
                            inputsInline: true,
                            previousStatement: null,
                            nextStatement: null,
                            colour: 120,
                            tooltip: 'for 迴圈',
                            helpUrl: ''
                        });
                    }
                };
            }

            // 註冊數學積木
            if (!Blockly.Blocks['math_number']) {
                Blockly.Blocks['math_number'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'math_number',
                            message0: '%1',
                            args0: [
                                { type: 'field_number', name: 'NUM', value: 0 }
                            ],
                            output: 'Number',
                            colour: 230,
                            tooltip: '數字',
                            helpUrl: ''
                        });
                    }
                };
            }

            if (!Blockly.Blocks['math_arithmetic']) {
                Blockly.Blocks['math_arithmetic'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'math_arithmetic',
                            message0: '%1 %2 %3',
                            args0: [
                                { type: 'input_value', name: 'A', check: 'Number' },
                                {
                                    type: 'field_dropdown',
                                    name: 'OP',
                                    options: [
                                        ['+', 'ADD'],
                                        ['-', 'MINUS'],
                                        ['×', 'MULTIPLY'],
                                        ['÷', 'DIVIDE'],
                                        ['^', 'POWER']
                                    ]
                                },
                                { type: 'input_value', name: 'B', check: 'Number' }
                            ],
                            inputsInline: true,
                            output: 'Number',
                            colour: 230,
                            tooltip: '數學運算',
                            helpUrl: ''
                        });
                    }
                };
            }

            // 註冊基本文字積木
            if (!Blockly.Blocks['text']) {
                Blockly.Blocks['text'] = {
                    init: function() {
                        this.jsonInit({
                            type: 'text',
                            message0: '%1',
                            args0: [
                                { type: 'field_input', name: 'TEXT', text: '' }
                            ],
                            output: 'String',
                            colour: 160,
                            tooltip: '文字',
                            helpUrl: ''
                        });
                    }
                };
            }

            // Arduino 積木由 ArduinoBlocks.ts 自動註冊




            // 變數積木由 ArduinoBlocks.ts 自動註冊

        }


        // 顯示變數名稱輸入對話框（異步版本）
        function showVariableNameDialogAsync(message, suggestedName, callback) {
            console.log('🎨 Creating async variable dialog:', message, suggestedName);
            // 創建對話框元素
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 999999;
            `;

            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: #2d2d30;
                border: 2px solid #007acc;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
                min-width: 320px;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            `;

            const title = document.createElement('h3');
            title.textContent = message || '建立新變數';
            title.style.cssText = 'margin: 0 0 15px 0; color: #ffffff; font-size: 18px;';

            const description = document.createElement('p');
            description.textContent = '請輸入變數名稱：';
            description.style.cssText = 'margin: 0 0 10px 0; color: #cccccc; font-size: 14px;';

            const input = document.createElement('input');
            input.type = 'text';
            input.value = suggestedName;
            input.placeholder = '變數名稱...';
            input.style.cssText = `
                width: 100%;
                padding: 10px;
                border: 2px solid #007acc;
                border-radius: 4px;
                font-size: 14px;
                margin-bottom: 20px;
                box-sizing: border-box;
                outline: none;
                background: #1e1e1e;
                color: #ffffff;
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';

            const cancelButton = document.createElement('button');
            cancelButton.textContent = '取消';
            cancelButton.style.cssText = `
                padding: 10px 20px;
                border: 2px solid #666;
                background: #3c3c3c;
                color: #ffffff;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            `;

            const confirmButton = document.createElement('button');
            confirmButton.textContent = '建立';
            confirmButton.style.cssText = `
                padding: 10px 20px;
                border: 2px solid #007acc;
                background: #007acc;
                color: #ffffff;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
            `;

            // 異步事件處理
            function closeDialog(returnValue) {
                console.log('🚪 Async dialog closing with result:', returnValue);
                try {
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                        console.log('🗑️ Async dialog removed from DOM');
                    }
                } catch (e) {
                    console.warn('Error removing async dialog from DOM:', e);
                }
                // 調用回調函數
                callback(returnValue);
            }

            cancelButton.addEventListener('click', () => {
                closeDialog(null);
            });

            confirmButton.addEventListener('click', () => {
                const variableName = input.value.trim();
                closeDialog(variableName || null);
            });

            // 鍵盤事件
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    confirmButton.click();
                } else if (e.key === 'Escape') {
                    cancelButton.click();
                }
            });

            // 組裝對話框
            buttonContainer.appendChild(cancelButton);
            buttonContainer.appendChild(confirmButton);

            dialog.appendChild(title);
            dialog.appendChild(description);
            dialog.appendChild(input);
            dialog.appendChild(buttonContainer);

            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            console.log('📱 Async dialog added to DOM');

            // 聚焦輸入框並選中文字
            setTimeout(() => {
                input.focus();
                input.select();
                console.log('🎯 Async dialog input focused');
            }, 50);

            // 點擊覆蓋層關閉
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeDialog(null);
                }
            });
        }

        // 工作區變更事件（手動同步模式 - 僅更新計數）
        function onWorkspaceChange(event) {
            console.log('Workspace change event:', event.type);

            // 僅更新積木數量，不自動同步
            updateBlockCount();

            // 手動同步模式 - 不自動生成程式碼或發送變更通知
            console.log('Manual sync mode - auto sync disabled');
        }

        // 生成程式碼
        function generateCode() {
            try {
                console.log('generateCode called');
                const code = generateArduinoCode();
                console.log('Generated code:', code.substring(0, 100));

                // 智能即時同步到右側編輯器
                console.log('Sending smartSyncCode message to VSCode');
                vscode.postMessage({
                    command: 'smartSyncCode',
                    data: { code: code }
                });

                hideError();
            } catch (error) {
                showError('程式碼生成失敗: ' + error.message);
                console.error('程式碼生成錯誤:', error);
            }
        }

        // 生成 Arduino 程式碼
        function generateArduinoCode() {
            const setupBlocks = workspace.getBlocksByType('arduino_setup');
            const loopBlocks = workspace.getBlocksByType('arduino_loop');

            // 收集全域變數定義 - 只收集不在 setup 或 loop 函數內的變數
            const allVarBlocks = workspace.getBlocksByType('variables_define');
            const globalVarBlocks = allVarBlocks.filter(block => {
                // 檢查變數是否在 setup 或 loop 函數內
                let parentBlock = block.getParent();
                while (parentBlock) {
                    if (parentBlock.type === 'arduino_setup' || parentBlock.type === 'arduino_loop') {
                        return false; // 在函數內，不是全域變數
                    }
                    parentBlock = parentBlock.getParent();
                }
                return true; // 不在函數內，是全域變數
            });

            let globalVarCode = '';
            if (globalVarBlocks.length > 0) {
                globalVarCode = globalVarBlocks.map(block => generateSingleBlockCode(block, '')).join('\n') + '\n';
            }

            let setupCode = '  // 初始化程式碼';
            let loopCode = '  // 主要程式邏輯';

            if (setupBlocks.length > 0) {
                const generatedSetup = generateBlockCode(setupBlocks[0].getInputTargetBlock('SETUP_CODE'), '  ');
                if (generatedSetup && generatedSetup.trim() !== '// 請拖曳積木到這裡') {
                    setupCode = generatedSetup;
                }
            }

            if (loopBlocks.length > 0) {
                const generatedLoop = generateBlockCode(loopBlocks[0].getInputTargetBlock('LOOP_CODE'), '  ');
                if (generatedLoop && generatedLoop.trim() !== '// 請拖曳積木到這裡') {
                    loopCode = generatedLoop;
                }
            }

            // 確保程式碼有正確的縮排
            const formattedSetupCode = formatCodeLines(setupCode, '  ');
            const formattedLoopCode = formatCodeLines(loopCode, '  ');

            // 生成時間戳
            const now = new Date();
            const timestamp = now.toLocaleString();

            return `// Arduino 程式碼
// 由 TextBlockly 自動生成
// 生成時間: ${timestamp}

${globalVarCode}void setup() {
${formattedSetupCode}
}

void loop() {
${formattedLoopCode}
}`;
        }

        // 格式化程式碼行，確保正確縮排
        function formatCodeLines(code, baseIndent) {
            if (!code || code.trim() === '') {
                return baseIndent + '// 請拖曳積木到這裡';
            }

            return code.split('\n')
                .map(line => {
                    const trimmed = line.trim();
                    if (trimmed === '' || trimmed.startsWith('//')) {
                        return line; // 保持註解和空行原樣
                    }
                    // 確保每行都有基本縮排，除非已經有縮排
                    if (!line.startsWith(' ') && !line.startsWith('\t')) {
                        return baseIndent + trimmed;
                    }
                    return line;
                })
                .join('\n');
        }

        // 生成積木程式碼
        function generateBlockCode(block, indent = '  ') {
            if (!block) return '  // 請拖曳積木到這裡';

            let code = '';
            let currentBlock = block;

            while (currentBlock) {
                const blockCode = generateSingleBlockCode(currentBlock, indent);
                if (blockCode) {
                    code += blockCode + '\n';
                }
                currentBlock = currentBlock.getNextBlock();
            }

            return code.trim() || '  // 請拖曳積木到這裡';
        }

        // 生成單一積木程式碼
        function generateSingleBlockCode(block, indent) {
            const blockType = block.type;

            switch (blockType) {
                // Arduino 特定積木
                case 'arduino_digitalwrite':
                    const pin = generateValueCode(block.getInputTargetBlock('PIN')) || '13';
                    const state = block.getFieldValue('STATE') || 'HIGH';
                    return `${indent}digitalWrite(${pin}, ${state});`;

                case 'arduino_digitalread':
                    const readPin = generateValueCode(block.getInputTargetBlock('PIN')) || '2';
                    return `digitalRead(${readPin})`;

                case 'arduino_pinmode':
                    const modePin = generateValueCode(block.getInputTargetBlock('PIN')) || '13';
                    const pinMode = block.getFieldValue('MODE') || 'OUTPUT';
                    return `${indent}pinMode(${modePin}, ${pinMode});`;

                case 'arduino_analogread':
                    const analogPin = generateValueCode(block.getInputTargetBlock('PIN')) || 'A0';
                    return `analogRead(${analogPin})`;

                case 'arduino_analogwrite':
                    const pwmPin = generateValueCode(block.getInputTargetBlock('PIN')) || '9';
                    const pwmValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '128';
                    return `${indent}analogWrite(${pwmPin}, ${pwmValue});`;

                case 'arduino_pin':
                    return block.getFieldValue('PIN') || 'A0';

                case 'arduino_raw_statement':
                    const rawStatement = block.getFieldValue('CODE') || '';
                    // 檢查是否已經有分號結尾，避免重複添加
                    const trimmedStatement = rawStatement.trim();
                    if (trimmedStatement.endsWith(';') || trimmedStatement.endsWith('}') || trimmedStatement === '') {
                        return `${indent}${rawStatement}`;
                    }
                    return `${indent}${rawStatement};`;

                case 'arduino_raw_expression':
                    const rawExpression = block.getFieldValue('CODE') || '';
                    return rawExpression;

                case 'arduino_raw_block':
                    const rawBlockCode = block.getFieldValue('CODE') || '';
                    const statements = generateStatements(block, 'STATEMENTS', indent + '  ');
                    return `${indent}${rawBlockCode} {\n${statements}${indent}}`;

                case 'arduino_delay':
                    const delayTime = validateNumber(block.getFieldValue('TIME'), '1000', 0);
                    return `${indent}delay(${delayTime});`;

                case 'arduino_delayMicroseconds':
                    const microTime = validateNumber(block.getFieldValue('TIME'), '1000', 0, 16383);
                    return `${indent}delayMicroseconds(${microTime});`;

                // Serial 通訊積木
                case 'arduino_serial_begin':
                    const baudRate = generateValueCode(block.getInputTargetBlock('BAUD')) || '9600';
                    return `${indent}Serial.begin(${baudRate});`;

                case 'arduino_serial_print':
                    const mode = block.getFieldValue('MODE') || 'PRINT';
                    const text = generateValueCode(block.getInputTargetBlock('TEXT')) || '""';
                    const methodName = mode === 'PRINTLN' ? 'println' : 'print';
                    return `${indent}Serial.${methodName}(${text});`;

                case 'arduino_serial_available':
                    return 'Serial.available()';

                case 'arduino_serial_read':
                    return 'Serial.read()';

                case 'arduino_serial_read_string':
                    return 'Serial.readString()';

                // Arduino 數學函數積木
                case 'arduino_map':
                    const mapValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';
                    const fromLow = generateValueCode(block.getInputTargetBlock('FROM_LOW')) || '0';
                    const fromHigh = generateValueCode(block.getInputTargetBlock('FROM_HIGH')) || '1023';
                    const toLow = generateValueCode(block.getInputTargetBlock('TO_LOW')) || '0';
                    const toHigh = generateValueCode(block.getInputTargetBlock('TO_HIGH')) || '255';
                    return `map(${mapValue}, ${fromLow}, ${fromHigh}, ${toLow}, ${toHigh})`;

                case 'arduino_constrain':
                    const constrainValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';
                    const minValue = generateValueCode(block.getInputTargetBlock('MIN')) || '0';
                    const maxValue = generateValueCode(block.getInputTargetBlock('MAX')) || '255';
                    return `constrain(${constrainValue}, ${minValue}, ${maxValue})`;

                case 'arduino_min':
                    const minA = generateValueCode(block.getInputTargetBlock('A')) || '0';
                    const minB = generateValueCode(block.getInputTargetBlock('B')) || '0';
                    return `min(${minA}, ${minB})`;

                case 'arduino_max':
                    const maxA = generateValueCode(block.getInputTargetBlock('A')) || '0';
                    const maxB = generateValueCode(block.getInputTargetBlock('B')) || '0';
                    return `max(${maxA}, ${maxB})`;

                case 'arduino_abs':
                    const absValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';
                    return `abs(${absValue})`;

                case 'arduino_pow':
                    const powBase = generateValueCode(block.getInputTargetBlock('BASE')) || '2';
                    const powExp = generateValueCode(block.getInputTargetBlock('EXPONENT')) || '2';
                    return `pow(${powBase}, ${powExp})`;

                case 'arduino_sqrt':
                    const sqrtValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '4';
                    return `sqrt(${sqrtValue})`;

                // Arduino 時間函數積木
                case 'arduino_millis':
                    return 'millis()';

                case 'arduino_micros':
                    return 'micros()';

                // Arduino 隨機數積木
                case 'arduino_random':
                    const randomMin = generateValueCode(block.getInputTargetBlock('MIN')) || '0';
                    const randomMax = generateValueCode(block.getInputTargetBlock('MAX')) || '100';
                    return `random(${randomMin}, ${randomMax})`;

                case 'arduino_random_seed':
                    const seed = generateValueCode(block.getInputTargetBlock('SEED')) || 'analogRead(0)';
                    return `${indent}randomSeed(${seed});`;

                // 文字處理積木
                case 'text_string':
                    const stringValue = block.getFieldValue('TEXT') || '';
                    return `"${stringValue}"`;

                case 'text_join':
                    const textA = generateValueCode(block.getInputTargetBlock('A')) || '""';
                    const textB = generateValueCode(block.getInputTargetBlock('B')) || '""';
                    return `(String(${textA}) + String(${textB}))`;

                case 'text_length':
                    const lengthValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '""';
                    return `String(${lengthValue}).length()`;

                case 'text_isEmpty':
                    const emptyValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '""';
                    return `(String(${emptyValue}).length() == 0)`;

                case 'text_indexOf':
                    const searchValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '""';
                    const findValue = generateValueCode(block.getInputTargetBlock('FIND')) || '""';
                    return `String(${searchValue}).indexOf(String(${findValue}))`;

                case 'text_charAt':
                    const charValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '""';
                    const charAt = generateValueCode(block.getInputTargetBlock('AT')) || '0';
                    return `String(${charValue}).charAt(${charAt})`;

                case 'text_substring':
                    const subString = generateValueCode(block.getInputTargetBlock('STRING')) || '""';
                    const subFrom = generateValueCode(block.getInputTargetBlock('FROM')) || '0';
                    const subTo = generateValueCode(block.getInputTargetBlock('TO')) || '1';
                    return `String(${subString}).substring(${subFrom}, ${subTo})`;

                case 'text_changeCase':
                    const caseText = generateValueCode(block.getInputTargetBlock('TEXT')) || '""';
                    const caseMode = block.getFieldValue('CASE') || 'UPPERCASE';
                    const caseMethod = caseMode === 'UPPERCASE' ? 'toUpperCase' : 'toLowerCase';
                    return `String(${caseText}).${caseMethod}()`;

                case 'text_trim':
                    const trimText = generateValueCode(block.getInputTargetBlock('TEXT')) || '""';
                    return `String(${trimText}).trim()`;

                case 'text_replace':
                    const replaceText = generateValueCode(block.getInputTargetBlock('TEXT')) || '""';
                    const replaceFrom = generateValueCode(block.getInputTargetBlock('FROM')) || '""';
                    const replaceTo = generateValueCode(block.getInputTargetBlock('TO')) || '""';
                    return `String(${replaceText}).replace(String(${replaceFrom}), String(${replaceTo}))`;

                case 'text_number_conversion':
                    const convertValue = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';
                    const convertType = block.getFieldValue('TYPE') || 'STRING';
                    if (convertType === 'STRING') {
                        return `String(${convertValue})`;
                    } else {
                        return `String(${convertValue}).toInt()`;
                    }

                // 控制流程積木
                case 'controls_if':
                    return generateControlsIf(block, indent);

                case 'controls_repeat_ext':
                    return generateControlsRepeat(block, indent);

                case 'controls_whileUntil':
                    return generateControlsWhile(block, indent);

                case 'controls_for':
                    return generateControlsFor(block, indent);

                // 邏輯積木
                case 'logic_compare':
                    return generateLogicCompare(block);

                case 'logic_operation':
                    return generateLogicOperation(block);

                case 'logic_negate':
                    return generateLogicNegate(block);

                case 'logic_boolean':
                    return generateLogicBoolean(block);

                // 數學和基本積木
                case 'math_number':
                    return validateNumber(block.getFieldValue('NUM'), '0');

                case 'math_arithmetic':
                    return generateMathArithmetic(block);

                case 'text':
                    const textValue = block.getFieldValue('TEXT') || '';
                    // 檢查是否為 Arduino 常數（如 A0-A5, HIGH, LOW）
                    if (/^A[0-5]$/.test(textValue) || /^(HIGH|LOW|INPUT|OUTPUT|INPUT_PULLUP)$/.test(textValue)) {
                        return textValue;
                    }
                    return `"${textValue}"`;

                case 'number':
                    return validateNumber(block.getFieldValue('NUM'), '0');

                // 變數積木
                case 'variables_get':
                    return validateVariableName(block.getFieldValue('VAR'), 'variable');

                case 'variables_set':
                    return generateVariablesSet(block, indent);

                case 'variables_declare':
                    return generateVariablesDeclare(block, indent);

                case 'variables_define':
                    return generateVariablesDefine(block, indent);

                default:
                    console.warn(`Unknown block type: ${blockType}`);
                    return `${indent}// TODO: ${blockType} 積木`;
            }
        }

        // 控制流程積木生成函數
        function generateControlsIf(block, indent) {
            const condition = generateValueCode(block.getInputTargetBlock('IF0')) || 'true';
            const doCode = generateBlockCode(block.getInputTargetBlock('DO0'), indent + '  ');
            const elseCode = generateBlockCode(block.getInputTargetBlock('ELSE'), indent + '  ');

            // 確保 doCode 每一行都有正確的縮排
            const formattedDoCode = doCode.split('\n')
                .map(line => line.trim() ? (line.startsWith(indent + '  ') ? line : indent + '  ' + line.trim()) : line)
                .join('\n');

            let code = `${indent}if (${condition}) {\n${formattedDoCode}\n${indent}}`;

            if (elseCode && elseCode.trim() !== '// 請拖曳積木到這裡') {
                const formattedElseCode = elseCode.split('\n')
                    .map(line => line.trim() ? (line.startsWith(indent + '  ') ? line : indent + '  ' + line.trim()) : line)
                    .join('\n');
                code += ` else {\n${formattedElseCode}\n${indent}}`;
            }
            return code;
        }

        function generateControlsRepeat(block, indent) {
            const times = validateNumber(generateValueCode(block.getInputTargetBlock('TIMES')), '10', 0);
            const doCode = generateBlockCode(block.getInputTargetBlock('DO'), indent + '  ');

            const formattedDoCode = doCode.split('\n')
                .map(line => line.trim() ? (line.startsWith(indent + '  ') ? line : indent + '  ' + line.trim()) : line)
                .join('\n');

            return `${indent}for (int i = 0; i < ${times}; i++) {\n${formattedDoCode}\n${indent}}`;
        }

        function generateControlsWhile(block, indent) {
            const mode = block.getFieldValue('MODE');
            const condition = generateValueCode(block.getInputTargetBlock('BOOL')) || 'true';
            const doCode = generateBlockCode(block.getInputTargetBlock('DO'), indent + '  ');

            const formattedDoCode = doCode.split('\n')
                .map(line => line.trim() ? (line.startsWith(indent + '  ') ? line : indent + '  ' + line.trim()) : line)
                .join('\n');

            const whileCondition = mode === 'WHILE' ? condition : `!(${condition})`;
            return `${indent}while (${whileCondition}) {\n${formattedDoCode}\n${indent}}`;
        }

        function generateControlsFor(block, indent) {
            const variable = validateVariableName(block.getFieldValue('VAR'), 'i');
            const from = validateNumber(generateValueCode(block.getInputTargetBlock('FROM')), '1');
            const to = validateNumber(generateValueCode(block.getInputTargetBlock('TO')), '10');
            const by = validateNumber(generateValueCode(block.getInputTargetBlock('BY')), '1');
            const doCode = generateBlockCode(block.getInputTargetBlock('DO'), indent + '  ');

            const formattedDoCode = doCode.split('\n')
                .map(line => line.trim() ? (line.startsWith(indent + '  ') ? line : indent + '  ' + line.trim()) : line)
                .join('\n');

            return `${indent}for (int ${variable} = ${from}; ${variable} <= ${to}; ${variable} += ${by}) {\n${formattedDoCode}\n${indent}}`;
        }

        // 邏輯積木生成函數
        function generateLogicCompare(block) {
            const operator = block.getFieldValue('OP');
            const a = generateValueCode(block.getInputTargetBlock('A')) || '0';
            const b = generateValueCode(block.getInputTargetBlock('B')) || '0';

            const operators = {
                'EQ': '==', 'NEQ': '!=', 'LT': '<', 'LTE': '<=', 'GT': '>', 'GTE': '>='
            };

            return `${a} ${operators[operator] || '=='} ${b}`;
        }

        function generateLogicOperation(block) {
            const operator = block.getFieldValue('OP');
            const a = generateValueCode(block.getInputTargetBlock('A')) || 'false';
            const b = generateValueCode(block.getInputTargetBlock('B')) || 'false';

            return `${a} ${operator === 'AND' ? '&&' : '||'} ${b}`;
        }

        function generateLogicNegate(block) {
            const bool = generateValueCode(block.getInputTargetBlock('BOOL')) || 'false';
            return `!(${bool})`;
        }

        function generateLogicBoolean(block) {
            return block.getFieldValue('BOOL') === 'TRUE' ? 'true' : 'false';
        }

        // 數學積木生成函數
        function generateMathArithmetic(block) {
            const operator = block.getFieldValue('OP');
            const a = generateValueCode(block.getInputTargetBlock('A')) || '0';
            const b = generateValueCode(block.getInputTargetBlock('B')) || '0';

            const operators = {
                'ADD': '+', 'MINUS': '-', 'MULTIPLY': '*', 'DIVIDE': '/', 'POWER': 'pow'
            };

            if (operator === 'POWER') {
                return `pow(${a}, ${b})`;
            }

            return `${a} ${operators[operator] || '+'} ${b}`;
        }

        // 變數積木生成函數
        function generateVariablesSet(block, indent) {
            const variable = validateVariableName(block.getFieldValue('VAR'), 'variable');
            const value = generateValueCode(block.getInputTargetBlock('VALUE')) || '0';

            return `${indent}${variable} = ${value};`;
        }

        function generateVariablesDeclare(block, indent) {
            const type = block.getFieldValue('TYPE') || 'int';
            const variable = validateVariableName(block.getFieldValue('VAR'), 'myVar');

            return `${indent}${type} ${variable};`;
        }

        function generateVariablesDefine(block, indent) {
            const type = block.getFieldValue('TYPE') || 'int';
            const variable = validateVariableName(block.getFieldValue('VAR'), 'myVar');
            const value = generateValueCode(block.getInputTargetBlock('VALUE')) || getDefaultValueForType(type);

            return `${type} ${variable} = ${value};`;
        }

        // 根據類型取得預設值
        function getDefaultValueForType(type) {
            switch (type) {
                case 'int':
                    return '0';
                case 'float':
                    return '0.0';
                case 'boolean':
                    return 'false';
                case 'char':
                    return "'a'";
                case 'String':
                    return '""';
                default:
                    return '0';
            }
        }

        // 輔助函數：生成值表達式的程式碼
        function generateValueCode(block) {
            if (!block) {
                return '';
            }
            return generateSingleBlockCode(block, '').trim();
        }

        // 驗證和清理數值
        function validateNumber(value, defaultValue = '0', min = null, max = null) {
            if (value === null || value === undefined || value === '') {
                return defaultValue;
            }

            const num = parseFloat(value);
            if (isNaN(num)) {
                return defaultValue;
            }

            if (min !== null && num < min) {
                return min.toString();
            }

            if (max !== null && num > max) {
                return max.toString();
            }

            // 對於整數，移除小數點
            if (Number.isInteger(num)) {
                return Math.floor(num).toString();
            }

            return num.toString();
        }

        // 驗證和清理變數名稱
        function validateVariableName(name, defaultName = 'variable') {
            if (!name || typeof name !== 'string') {
                return defaultName;
            }

            // 嘗試從 workspace 中獲取變數的實際名稱
            if (workspace) {
                const variable = workspace.getVariableById(name);
                if (variable && variable.name) {
                    name = variable.name;
                }
            }

            // 移除無效字符，只保留字母、數字和底線
            let cleanName = name.replace(/[^a-zA-Z0-9_]/g, '');

            // 確保以字母或底線開始
            if (cleanName && /^[0-9]/.test(cleanName)) {
                cleanName = '_' + cleanName;
            }

            // 如果清理後為空，使用預設名稱
            if (!cleanName) {
                return defaultName;
            }

            // 避免 Arduino 關鍵字
            const arduinoKeywords = ['setup', 'loop', 'void', 'int', 'float', 'char', 'byte', 'boolean', 'true', 'false', 'HIGH', 'LOW'];
            if (arduinoKeywords.includes(cleanName.toLowerCase())) {
                return '_' + cleanName;
            }

            return cleanName;
        }

        // 手動同步：積木到程式碼
        function manualSyncToCode() {
            try {
                showLoading();
                console.log('Manual sync: blocks to code');

                // 檢查工作區中的積木
                const allBlocks = workspace.getAllBlocks();
                console.log('Total blocks in workspace:', allBlocks.length);
                console.log('Block types:', allBlocks.map(b => b.type));

                // 如果工作區是空的，自動創建基本的 setup 和 loop 積木
                if (allBlocks.length === 0) {
                    console.log('Workspace is empty, creating default blocks');
                    createTestBlocks();
                }

                const code = generateArduinoCode();
                console.log('Generated code (full):');
                console.log(code);
                console.log('Code length:', code.length);

                if (!code || code.trim().length === 0) {
                    hideLoading();
                    showError('無法生成程式碼：工作區為空或積木無效');
                    return;
                }

                // 發送同步訊息到 VSCode
                vscode.postMessage({
                    command: 'manualSyncToCode',
                    data: { code: code }
                });

                hideLoading();
                console.log('Manual sync to code completed');
            } catch (error) {
                hideLoading();
                showError('同步到程式碼失敗: ' + error.message);
                console.error('Manual sync to code error:', error);
            }
        }

        // 手動同步：程式碼到積木
        function manualSyncToBlocks() {
            try {
                showLoading();
                console.log('Manual sync: code to blocks');

                // 請求 VSCode 提供當前程式碼
                vscode.postMessage({
                    command: 'manualSyncToBlocks'
                });

                console.log('Manual sync to blocks request sent');
            } catch (error) {
                hideLoading();
                showError('同步到積木失敗: ' + error.message);
                console.error('Manual sync to blocks error:', error);
            }
        }

        // 顯示載入狀態
        function showLoading() {
            document.getElementById('loading').style.display = 'flex';
        }

        // 隱藏載入狀態
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // 更新積木數量
        function updateBlockCount() {
            const count = workspace.getAllBlocks().length;
            document.getElementById('blockCount').textContent = count;
        }


        // 顯示錯誤訊息
        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
        }

        // 隱藏錯誤訊息
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        // 工具列按鈕事件
        document.getElementById('saveBtn').addEventListener('click', () => {
            let xmlText;
            try {
                if (typeof Blockly.utils !== 'undefined' && Blockly.utils.xml) {
                    // 新版 Blockly API
                    const xmlDom = Blockly.serialization.workspaces.save(workspace);
                    xmlText = Blockly.utils.xml.domToText(xmlDom);
                } else if (typeof Blockly.Xml !== 'undefined' && typeof Blockly.Xml.workspaceToDom === 'function') {
                    // 舊版 Blockly API
                    const xmlDom = Blockly.Xml.workspaceToDom(workspace);
                    if (typeof Blockly.Xml.domToText === 'function') {
                        xmlText = Blockly.Xml.domToText(xmlDom);
                    } else {
                        xmlText = new XMLSerializer().serializeToString(xmlDom);
                    }
                } else {
                    xmlText = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
                }
            } catch (error) {
                console.error('Error saving template:', error);
                xmlText = '<xml xmlns="https://developers.google.com/blockly/xml"></xml>';
            }

            vscode.postMessage({
                command: 'saveTemplate',
                data: { xml: xmlText }
            });
        });

        document.getElementById('loadBtn').addEventListener('click', () => {
            vscode.postMessage({ command: 'loadTemplate' });
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('確定要清空工作區嗎？')) {
                workspace.clear();
            }
        });


        document.getElementById('syncToCodeBtn').addEventListener('click', () => {
            console.log('Sync to code button clicked');
            manualSyncToCode();
        });

        document.getElementById('syncToBlocksBtn').addEventListener('click', () => {
            console.log('Sync to blocks button clicked');
            manualSyncToBlocks();
        });


        // VSCode 訊息處理
        window.addEventListener('message', event => {
            const message = event.data;
            console.log('Received message from VSCode:', message.command);

            switch (message.command) {
                case 'loadWorkspace':
                    if (message.data && message.data.xml) {
                        console.log('Loading workspace from XML:', message.data.xml.substring(0, 200));
                        console.log('Full XML length:', message.data.xml.length);

                        // 檢查XML中是否包含loop內容
                        if (message.data.xml.includes('LOOP_CODE')) {
                            console.log('✅ XML contains LOOP_CODE section');
                            if (message.data.xml.includes('variables_define')) {
                                console.log('✅ XML contains variables_define blocks');
                            } else {
                                console.log('❌ XML missing variables_define blocks');
                            }
                            if (message.data.xml.includes('arduino_serial_print')) {
                                console.log('✅ XML contains arduino_serial_print blocks');
                            } else {
                                console.log('❌ XML missing arduino_serial_print blocks');
                            }
                        } else {
                            console.log('❌ XML missing LOOP_CODE section');
                        }

                        try {
                            // 暫時禁用工作區變更事件以防止循環
                            workspace.removeChangeListener(onWorkspaceChange);

                            // 清空現有工作區
                            workspace.clear();

                            // 預處理變數：在載入 XML 之前創建所有變數
                            const varMatches = message.data.xml.match(/<field name="VAR">([^<]+)<\/field>/g);
                            if (varMatches) {
                                const uniqueVars = new Set();
                                varMatches.forEach(match => {
                                    const varName = match.match(/<field name="VAR">([^<]+)<\/field>/)[1];
                                    uniqueVars.add(varName);
                                });

                                console.log('📋 Creating variables before XML load:', Array.from(uniqueVars));
                                uniqueVars.forEach(varName => {
                                    try {
                                        // 創建變數，變數名稱和 ID 都使用同一個名稱
                                        workspace.createVariable(varName, null, varName);
                                    } catch (error) {
                                        console.log('變數創建失敗:', varName, error);
                                    }
                                });
                            }

                            // 載入新的工作區 - 使用不同的 API 方法
                            let xml;
                            let loadSuccess = false;

                            // 嘗試新版 Blockly API（但使用 XML 而不是 serialization）
                            if (typeof Blockly.utils !== 'undefined' && Blockly.utils.xml) {
                                try {
                                    console.log('Trying new Blockly API (utils.xml)');
                                    xml = Blockly.utils.xml.textToDom(message.data.xml);
                                    // 使用 Xml.domToWorkspace 而不是 serialization.workspaces.load
                                    if (typeof Blockly.Xml !== 'undefined' && typeof Blockly.Xml.domToWorkspace === 'function') {
                                        Blockly.Xml.domToWorkspace(xml, workspace);
                                        loadSuccess = true;
                                        console.log('New API with domToWorkspace load successful');
                                    }
                                } catch (error) {
                                    console.log('New API failed:', error);
                                }
                            }

                            // 嘗試舊版 Blockly API
                            if (!loadSuccess && typeof Blockly.Xml !== 'undefined') {
                                if (typeof Blockly.Xml.textToDom === 'function') {
                                    try {
                                        console.log('Trying old Blockly API (Xml.textToDom)');
                                        xml = Blockly.Xml.textToDom(message.data.xml);
                                        Blockly.Xml.domToWorkspace(xml, workspace);
                                        loadSuccess = true;
                                        console.log('Old API load successful');
                                    } catch (error) {
                                        console.log('Old API with textToDom failed:', error);
                                    }
                                } else if (typeof Blockly.Xml.domToWorkspace === 'function') {
                                    try {
                                        console.log('Trying DOMParser + domToWorkspace');
                                        const parser = new DOMParser();
                                        xml = parser.parseFromString(message.data.xml, 'text/xml');
                                        Blockly.Xml.domToWorkspace(xml, workspace);
                                        loadSuccess = true;
                                        console.log('DOMParser + domToWorkspace successful');
                                    } catch (error) {
                                        console.log('DOMParser + domToWorkspace failed:', error);
                                    }
                                }
                            }

                            // 最後的備用方案 - 嘗試更簡單的方法
                            if (!loadSuccess) {
                                console.log('All standard methods failed, trying simplified approach');
                                try {
                                    // 嘗試最直接的方法
                                    const parser = new DOMParser();
                                    const xmlDoc = parser.parseFromString(message.data.xml, 'text/xml');
                                    const xmlElement = xmlDoc.documentElement;

                                    if (typeof Blockly.Xml.domToWorkspace === 'function') {
                                        Blockly.Xml.domToWorkspace(xmlElement, workspace);
                                        loadSuccess = true;
                                        console.log('Simplified domToWorkspace successful');
                                    }
                                } catch (error) {
                                    console.error('Simplified approach failed:', error);
                                    console.log('XML that failed to load:', message.data.xml);
                                }
                            }

                            // 重新啟用變更事件
                            setTimeout(() => {
                                workspace.addChangeListener(onWorkspaceChange);

                                // 檢查載入結果
                                const allBlocks = workspace.getAllBlocks();
                                console.log(`📊 Workspace loaded with ${allBlocks.length} total blocks`);

                                const setupBlocks = allBlocks.filter(block => block.type === 'arduino_setup');
                                const loopBlocks = allBlocks.filter(block => block.type === 'arduino_loop');
                                console.log(`- Setup blocks: ${setupBlocks.length}`);
                                console.log(`- Loop blocks: ${loopBlocks.length}`);

                                // 檢查loop積木的內容
                                if (loopBlocks.length > 0) {
                                    const loopBlock = loopBlocks[0];
                                    const loopConnection = loopBlock.getInput('LOOP_CODE');
                                    if (loopConnection && loopConnection.connection && loopConnection.connection.targetBlock()) {
                                        const connectedBlocks = [];
                                        let currentBlock = loopConnection.connection.targetBlock();
                                        while (currentBlock) {
                                            connectedBlocks.push(currentBlock.type);
                                            currentBlock = currentBlock.getNextBlock();
                                        }
                                        console.log(`🔗 Loop contains blocks: ${connectedBlocks.join(' → ')}`);
                                    } else {
                                        console.log('❌ Loop block has no connected blocks');
                                    }
                                }

                                updateBlockCount();
                            }, 100);

                            console.log('Workspace loaded successfully');
                            // 隱藏載入狀態
                            hideLoading();
                        } catch (error) {
                            console.error('Failed to load workspace:', error);
                            showError('載入工作區失敗: ' + error.message);
                            hideLoading();
                        }
                    }
                    break;
                case 'syncCode':
                    generateCode();
                    break;
            }
        });

        // 手動從 XML 創建積木（備用方案）
        function createBlocksFromXml(xmlDoc) {
            console.log('Creating blocks manually from XML');

            const blocks = xmlDoc.getElementsByTagName('block');
            console.log('Found', blocks.length, 'blocks in XML');

            for (let i = 0; i < blocks.length; i++) {
                const blockElement = blocks[i];
                const blockType = blockElement.getAttribute('type');
                console.log('Processing block type:', blockType);

                if (blockType === 'arduino_setup' || blockType === 'arduino_loop') {
                    console.log('Creating', blockType, 'block');

                    try {
                        // 檢查積木類型是否存在
                        if (!Blockly.Blocks[blockType]) {
                            console.error('Block type not found:', blockType);
                            console.log('Available block types:', Object.keys(Blockly.Blocks));
                            continue;
                        }

                        // 創建積木
                        const block = workspace.newBlock(blockType);
                        console.log('Block created:', block);

                        // 設置位置
                        const x = parseInt(blockElement.getAttribute('x')) || (blockType === 'arduino_setup' ? 50 : 50);
                        const y = parseInt(blockElement.getAttribute('y')) || (blockType === 'arduino_setup' ? 50 : 250);
                        console.log('Moving block to position:', x, y);
                        block.moveBy(x, y);

                        // 初始化並渲染積木
                        block.initSvg();
                        block.render();
                        console.log('Block rendered successfully');
                    } catch (error) {
                        console.error('Error creating block:', blockType, error);
                    }
                }
            }

            console.log('Manual block creation completed');
            console.log('Total blocks in workspace:', workspace.getAllBlocks().length);
        }

        // 手動創建兩個基本積木來測試顯示
        function createTestBlocks() {
            console.log('Creating test blocks manually');

            try {
                // 創建 setup 積木
                const setupBlock = workspace.newBlock('arduino_setup');
                setupBlock.moveBy(50, 50);
                setupBlock.initSvg();
                setupBlock.render();
                console.log('Setup block created');

                // 創建 loop 積木
                const loopBlock = workspace.newBlock('arduino_loop');
                loopBlock.moveBy(50, 250);
                loopBlock.initSvg();
                loopBlock.render();
                console.log('Loop block created');

                console.log('Test blocks created successfully');
                console.log('Total blocks in workspace:', workspace.getAllBlocks().length);
            } catch (error) {
                console.error('Error creating test blocks:', error);
                console.log('Available block types:', Object.keys(Blockly.Blocks));
            }
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', initBlockly);
    </script>
</body>
</html>